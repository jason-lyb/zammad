{"version":3,"file":"Form.vue_vue_type_script_setup_true_lang-B6L-6HzY.js","sources":["../../../../../app/frontend/shared/entities/object-attributes/composables/useObjectAttributeFormFields.ts","../../../../../app/frontend/shared/entities/object-attributes/composables/useObjectAttributeLoadFormFields.ts","../../../../../app/frontend/shared/components/Form/FormLayout.vue","../../../../../app/frontend/shared/components/Form/graphql/queries/formUpdater.api.ts","../../../../../app/frontend/shared/components/Form/Form.vue"],"sourcesContent":["// Copyright (C) 2012-2025 Zammad Foundation, https://zammad-foundation.org/\n\nimport type { FormSchemaField } from '#shared/components/Form/types.ts'\nimport type { EnumObjectManagerObjects } from '#shared/graphql/types.ts'\n\nimport { transformResolvedFieldForScreen } from '../form/getFieldFromAttribute.ts'\nimport { useObjectAttributesStore } from '../stores/objectAttributes.ts'\n\nimport type { ObjectAttribute } from '../types/store.ts'\n\nexport const useObjectAttributeFormFields = (skippedFields: string[] = []) => {\n  const { getObjectAttributesForObject } = useObjectAttributesStore()\n\n  const getFormFieldSchema = (\n    name: string,\n    object: EnumObjectManagerObjects,\n    screen?: string,\n  ) => {\n    const objectAttributesObject = getObjectAttributesForObject(object)\n\n    const resolvedField = (\n      objectAttributesObject.formFieldAttributesLookup as unknown as Map<\n        string,\n        FormSchemaField\n      >\n    ).get(name)\n\n    if (!screen) return resolvedField\n\n    // We need to transform the resolved the field for the current screen (e.g. for the required information).\n    const screenConfig = (\n      objectAttributesObject.attributesLookup as unknown as Map<\n        string,\n        ObjectAttribute\n      >\n    ).get(name)?.screens[screen]\n\n    if (resolvedField && screenConfig) {\n      transformResolvedFieldForScreen(screenConfig, resolvedField)\n    }\n\n    return resolvedField\n  }\n\n  const getFormFieldsFromScreen = (\n    screen: string,\n    object: EnumObjectManagerObjects,\n  ) => {\n    const screens = getObjectAttributesForObject(object)\n      .screens as unknown as Record<string, string[]>\n\n    if (!screens[screen]) return []\n\n    const formFields: FormSchemaField[] = []\n\n    screens[screen].forEach((attributeName) => {\n      if (skippedFields.includes(attributeName)) {\n        return\n      }\n      const formField = getFormFieldSchema(attributeName, object, screen)\n      if (!formField) {\n        return\n      }\n      formFields.push(formField)\n    })\n    return formFields\n  }\n\n  return {\n    getFormFieldSchema,\n    getFormFieldsFromScreen,\n  }\n}\n","// Copyright (C) 2012-2025 Zammad Foundation, https://zammad-foundation.org/\n\nimport { computed } from 'vue'\n\nimport type { EnumObjectManagerObjects } from '#shared/graphql/types.ts'\n\nimport { useObjectAttributes } from './useObjectAttributes.ts'\n\nexport const useObjectAttributeLoadFormFields = (\n  objectAttributeObjects: EnumObjectManagerObjects[],\n) => {\n  const objectAttributesByObject: Partial<\n    Record<EnumObjectManagerObjects, ReturnType<typeof useObjectAttributes>>\n  > = {}\n\n  objectAttributeObjects.forEach((object) => {\n    objectAttributesByObject[object] = useObjectAttributes(object)\n  })\n\n  const objectAttributesLoading = computed(() => {\n    let loading = false\n\n    const usedObjects = Object.keys(\n      objectAttributesByObject,\n    ) as EnumObjectManagerObjects[]\n\n    usedObjects.forEach((object: EnumObjectManagerObjects) => {\n      if (\n        (\n          objectAttributesByObject[object] as ReturnType<\n            typeof useObjectAttributes\n          >\n        ).formFieldAttributesLookup.value.size === 0\n      ) {\n        loading = true\n      }\n    })\n\n    return loading\n  })\n\n  return {\n    objectAttributesLoading,\n  }\n}\n","<!-- Copyright (C) 2012-2025 Zammad Foundation, https://zammad-foundation.org/ -->\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\n\ninterface Props {\n  columns?: number\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  columns: 1,\n})\n\nconst columnClass = computed(() => {\n  return `column-${props.columns}`\n})\n</script>\n\n<template>\n  <fieldset class=\"flex flex-wrap\" :class=\"columnClass\">\n    <slot />\n  </fieldset>\n</template>\n\n<style>\nfieldset.column-1 > .formkit-outer {\n  width: 100%;\n}\n\nfieldset.column-2 > .formkit-outer {\n  width: 50%;\n}\n\nfieldset.column-2 > .formkit-outer:first-child {\n  padding-right: 0.75rem;\n}\n</style>\n","import * as Types from '#shared/graphql/types.ts';\n\nimport gql from 'graphql-tag';\nimport * as VueApolloComposable from '@vue/apollo-composable';\nimport * as VueCompositionApi from 'vue';\nexport type ReactiveFunction<TParam> = () => TParam;\n\nexport const FormUpdaterDocument = gql`\n    query formUpdater($formUpdaterId: EnumFormUpdaterId!, $meta: FormUpdaterMetaInput!, $data: JSON!, $relationFields: [FormUpdaterRelationField!]!, $id: ID) {\n  formUpdater(\n    formUpdaterId: $formUpdaterId\n    meta: $meta\n    data: $data\n    relationFields: $relationFields\n    id: $id\n  ) {\n    fields\n    flags\n  }\n}\n    `;\nexport function useFormUpdaterQuery(variables: Types.FormUpdaterQueryVariables | VueCompositionApi.Ref<Types.FormUpdaterQueryVariables> | ReactiveFunction<Types.FormUpdaterQueryVariables>, options: VueApolloComposable.UseQueryOptions<Types.FormUpdaterQuery, Types.FormUpdaterQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<Types.FormUpdaterQuery, Types.FormUpdaterQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<Types.FormUpdaterQuery, Types.FormUpdaterQueryVariables>> = {}) {\n  return VueApolloComposable.useQuery<Types.FormUpdaterQuery, Types.FormUpdaterQueryVariables>(FormUpdaterDocument, variables, options);\n}\nexport function useFormUpdaterLazyQuery(variables?: Types.FormUpdaterQueryVariables | VueCompositionApi.Ref<Types.FormUpdaterQueryVariables> | ReactiveFunction<Types.FormUpdaterQueryVariables>, options: VueApolloComposable.UseQueryOptions<Types.FormUpdaterQuery, Types.FormUpdaterQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<Types.FormUpdaterQuery, Types.FormUpdaterQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<Types.FormUpdaterQuery, Types.FormUpdaterQueryVariables>> = {}) {\n  return VueApolloComposable.useLazyQuery<Types.FormUpdaterQuery, Types.FormUpdaterQueryVariables>(FormUpdaterDocument, variables, options);\n}\nexport type FormUpdaterQueryCompositionFunctionResult = VueApolloComposable.UseQueryReturn<Types.FormUpdaterQuery, Types.FormUpdaterQueryVariables>;","<!-- Copyright (C) 2012-2025 Zammad Foundation, https://zammad-foundation.org/ -->\n\n<script setup lang=\"ts\">\nimport { getNode, createMessage } from '@formkit/core'\nimport { FormKit, FormKitMessages, FormKitSchema } from '@formkit/vue'\nimport { refDebounced, watchOnce } from '@vueuse/shared'\nimport { isEqual, cloneDeep, merge, isEmpty, isObject } from 'lodash-es'\nimport {\n  useTemplateRef,\n  computed,\n  ref,\n  nextTick,\n  shallowRef,\n  reactive,\n  toRef,\n  watch,\n  markRaw,\n  useSlots,\n  onBeforeUnmount,\n  effectScope,\n} from 'vue'\n\nimport { NotificationTypes } from '#shared/components/CommonNotifications/types.ts'\nimport { useNotifications } from '#shared/components/CommonNotifications/useNotifications.ts'\nimport { useObjectAttributeFormFields } from '#shared/entities/object-attributes/composables/useObjectAttributeFormFields.ts'\nimport { useObjectAttributeLoadFormFields } from '#shared/entities/object-attributes/composables/useObjectAttributeLoadFormFields.ts'\nimport UserError from '#shared/errors/UserError.ts'\nimport type {\n  EnumObjectManagerObjects,\n  EnumFormUpdaterId,\n  FormUpdaterRelationField,\n  FormUpdaterQuery,\n  FormUpdaterQueryVariables,\n  ObjectAttributeValue,\n  FormUpdaterMetaInput,\n  FormUpdaterChangedFieldInput,\n} from '#shared/graphql/types.ts'\nimport { parseGraphqlId } from '#shared/graphql/utils.ts'\nimport { I18N, i18n } from '#shared/i18n.ts'\nimport { QueryHandler } from '#shared/server/apollo/handler/index.ts'\nimport type { EntityObject } from '#shared/types/entity.ts'\nimport type {\n  FormUpdaterAdditionalParams,\n  FormUpdaterOptions,\n  FormUpdaterTrigger,\n} from '#shared/types/form.ts'\nimport { camelize } from '#shared/utils/formatter.ts'\nimport { getFirstFocusableElement } from '#shared/utils/getFocusableElements.ts'\nimport getUuid from '#shared/utils/getUuid.ts'\nimport { edgesToArray } from '#shared/utils/helpers.ts'\nimport log from '#shared/utils/log.ts'\nimport { markup } from '#shared/utils/markup.ts'\nimport testFlags from '#shared/utils/testFlags.ts'\n\nimport FormGroup from './FormGroup.vue'\nimport FormLayout from './FormLayout.vue'\nimport { useFormUpdaterQuery } from './graphql/queries/formUpdater.api.ts'\nimport { getFormClasses } from './initializeFormClasses.ts'\nimport { FormHandlerExecution, FormValidationVisibility } from './types.ts'\nimport {\n  getNodeByName as getFormkitFieldNode,\n  getNodeId,\n  setErrors,\n} from './utils.ts'\n\nimport type {\n  ChangedField,\n  FormSubmitData,\n  FormFieldAdditionalProps,\n  FormFieldValue,\n  FormHandler,\n  FormHandlerFunction,\n  FormOnSubmitFunctionCallbacks,\n  FormSchemaField,\n  FormSchemaLayout,\n  FormSchemaNode,\n  FormValues,\n  ReactiveFormSchemData,\n  FormResetData,\n  FormResetOptions,\n} from './types.ts'\nimport type {\n  FormKitPlugin,\n  FormKitSchemaNode,\n  FormKitSchemaCondition,\n  FormKitNode,\n  FormKitClasses,\n  FormKitSchemaDOMNode,\n  FormKitSchemaComponent,\n  FormKitMessageProps,\n} from '@formkit/core'\nimport type { Except, SetRequired } from 'type-fest'\nimport type { Component, Ref, SetupContext } from 'vue'\n\nexport interface Props {\n  id?: string\n  schema?: FormSchemaNode[]\n  schemaData?: Except<ReactiveFormSchemData, 'fields' | 'flags'>\n  schemaComponentLibrary?: Record<string, Component>\n  handlers?: FormHandler[]\n  changeFields?: Record<string, Partial<FormSchemaField>>\n  formId?: string\n  formUpdaterId?: EnumFormUpdaterId\n  formUpdaterInitialOnly?: boolean\n  formUpdaterAdditionalParams?: FormUpdaterAdditionalParams\n  // Maybe in the future this is no longer needed, when FormKit supports group\n  // without value grouping below group name (https://github.com/formkit/formkit/issues/461).\n  flattenFormGroups?: string[]\n  formKitPlugins?: FormKitPlugin[]\n  formKitSectionsSchema?: Record<\n    string,\n    Partial<FormKitSchemaNode> | FormKitSchemaCondition\n  >\n  class?: FormKitClasses | string | Record<string, boolean>\n  formClass?: string | Record<string, string>\n\n  // Can be used to define initial values on frontend side and fetched schema from the server.\n  initialValues?: Partial<FormValues>\n  initialEntityObject?: EntityObject\n\n  validationVisibility?: FormValidationVisibility\n  disabled?: boolean\n  shouldAutofocus?: boolean\n\n  // Some special properties for working with object attribute fields inside of a form schema.\n  useObjectAttributes?: boolean\n  objectAttributeSkippedFields?: string[]\n\n  clearValuesAfterSubmit?: boolean\n\n  // Implement the submit in this way, because we need to react on async usage of the submit function.\n  // Don't forget that to submit a form with \"Enter\" key, you need to add a button with type=\"submit\" inside of the form.\n  // Or to have a button outside of form with \"form\" attribite with the same value as the form id.\n  // After this method is called, form resets its values and state. If you need to call something afterwards,\n  // like make route navigation, you can return a function from the submit handler, which will be called after the form reset.\n  // When you return \"false\" inside the submit function the handling will be stopped.\n  onSubmit?: (\n    values: FormSubmitData,\n    flags?: Record<string, boolean>,\n  ) =>\n    | Promise<void | (() => void) | FormOnSubmitFunctionCallbacks | false>\n    | void\n    | (() => void)\n    | FormOnSubmitFunctionCallbacks\n    | false\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  schema: () => {\n    return []\n  },\n  changeFields: () => {\n    return reactive({})\n  },\n  validationVisibility: FormValidationVisibility.Submit,\n  useObjectAttributes: false,\n})\n\nconst formId = props.formId ? props.formId : getUuid()\n\nconst slots: SetupContext['slots'] = useSlots()\n\nconst hasSchema = computed(\n  () => Boolean(slots.default) || Boolean(props.schema),\n)\nconst formSchemaInitialized = ref(false)\n\nif (!hasSchema.value) {\n  log.error(\n    'No schema defined. Please use the schema prop or the default slot for the schema.',\n  )\n}\n\n// Rename prop 'class' for usage in the template, because of reserved word\nconst localClass = toRef(props, 'class')\n\nconst emit = defineEmits<{\n  changed: [\n    fieldName: string,\n    newValue: FormFieldValue,\n    oldValue: FormFieldValue,\n  ]\n  node: [node: FormKitNode]\n  settled: []\n  focused: []\n}>()\n\nconst showInitialLoadingAnimation = ref(false)\nconst debouncedShowInitialLoadingAnimation = refDebounced(\n  showInitialLoadingAnimation,\n  300,\n)\n\nconst formKitInitialNodesSettled = ref(false)\nconst formInitialSettled = ref(false)\nconst formResetRunning = ref(false)\nconst formNode: Ref<FormKitNode | undefined> = ref()\nconst formElement = useTemplateRef('form')\n\nconst changeFields = toRef(props, 'changeFields')\n\nconst updaterChangedFields = new Set<string>()\nconst changeInitialValue = new Map<string, FormFieldValue>()\n\nconst getNodeByName = (id: string) => {\n  return getFormkitFieldNode(formId, id)\n}\n\nconst findNodeByName = (name: string) => {\n  return formNode.value?.find(name, 'name')\n}\n\nconst autofocusFirstInput = (node: FormKitNode) => {\n  nextTick(() => {\n    const firstInput = getFirstFocusableElement(formElement.value)\n\n    firstInput?.focus()\n    firstInput?.scrollIntoView({ block: 'nearest' })\n\n    const formName = node.context?.id || node.name\n    testFlags.set(`${formName}.focused`)\n    emit('focused')\n  })\n}\n\nconst setInitialEntityObjectToContext = (\n  node: FormKitNode,\n  object = props.initialEntityObject,\n) => {\n  if (node.context && object) {\n    node.context.initialEntityObject = object\n  }\n}\n\nconst setFormNode = (node: FormKitNode) => {\n  formNode.value = node\n\n  setInitialEntityObjectToContext(node)\n\n  node.settled.then(() => {\n    showInitialLoadingAnimation.value = false\n\n    nextTick(() => {\n      changeInitialValue.forEach((value, fieldName) => {\n        findNodeByName(fieldName)?.input(value, false)\n      })\n\n      changeInitialValue.clear()\n\n      formKitInitialNodesSettled.value = true\n\n      // Reset directly after the initial request.\n      updaterChangedFields.clear()\n\n      const formName = node.context?.id || node.name\n      testFlags.set(`${formName}.settled`)\n      emit('settled')\n\n      formInitialSettled.value = true\n\n      executeFormHandler(FormHandlerExecution.InitialSettled, values.value)\n\n      if (props.shouldAutofocus) autofocusFirstInput(node)\n    })\n  })\n\n  node.on('autofocus', () => autofocusFirstInput(node))\n\n  emit('node', node)\n}\n\nconst formNodeContext = computed(() => formNode.value?.context)\n\n// Build the flat value when its requested for specific form groups.\nconst getFlatValues = (values: FormValues, formGroups: string[]) => {\n  const flatValues = {\n    ...values,\n  }\n\n  formGroups.forEach((formGroup) => {\n    Object.assign(flatValues, flatValues[formGroup])\n    delete flatValues[formGroup]\n  })\n\n  return flatValues\n}\n\n// Use the node context value, instead of the v-model, because of performance reason.\nconst values = computed<FormValues>(() => {\n  if (!formNodeContext.value) {\n    return {}\n  }\n\n  if (!props.flattenFormGroups) return formNodeContext.value.value\n\n  return getFlatValues(formNodeContext.value.value, props.flattenFormGroups)\n})\n\nconst relationFields: FormUpdaterRelationField[] = []\nconst relationFieldBelongsToObjectField: Record<string, string> = {}\n\nconst formUpdaterProcessing = computed(\n  () => !!formNode.value?.context?.state.formUpdaterProcessing,\n)\n\nconst uploadProcessing = computed(\n  () => !!formNode.value?.context?.state.uploadProcessing,\n)\n\nlet delayedSubmit = false\nconst onSubmitRaw = () => {\n  if (formUpdaterProcessing.value || uploadProcessing.value) {\n    delayedSubmit = true\n  }\n}\n\nconst afterSubmitReset = (values: FormSubmitData) => {\n  if (!formNode.value) return\n\n  if (props.clearValuesAfterSubmit) {\n    formNode.value.reset()\n  } else {\n    formNode.value.reset(values)\n  }\n}\n\nconst afterSubmitHandling = (\n  submitReturn: void | (() => void) | FormOnSubmitFunctionCallbacks,\n  values: FormSubmitData,\n) => {\n  if (!formNode.value) return\n\n  schemaData.flags = {}\n\n  if (\n    isObject(submitReturn) &&\n    ('reset' in submitReturn || 'finally' in submitReturn)\n  ) {\n    if (submitReturn.reset) {\n      submitReturn.reset(values, formNode.value.value as FormValues)\n    } else {\n      afterSubmitReset(values)\n    }\n\n    submitReturn.finally?.()\n\n    return\n  }\n\n  afterSubmitReset(values)\n\n  if (typeof submitReturn === 'function') submitReturn()\n}\n\nconst onSubmit = (values: FormSubmitData) => {\n  // Needs to be checked, because the 'onSubmit' function is not required.\n  if (!props.onSubmit) return undefined\n\n  const flatValues = props.flattenFormGroups\n    ? getFlatValues(values, props.flattenFormGroups)\n    : values\n\n  formNode.value?.clearErrors()\n\n  const submitResult = props.onSubmit(flatValues, schemaData.flags)\n\n  if (submitResult !== undefined && submitResult === false) return\n\n  if (submitResult instanceof Promise) {\n    return submitResult\n      .then((result) => {\n        // When false was returned the submit was skipped.\n        if (result !== undefined && result === false) return\n\n        // it's possible to destroy Form before this is called and the reset should not run when errors exists.\n        if (!formNode.value || formNode.value.context?.state.errors) return\n\n        afterSubmitHandling(result, values)\n      })\n      .catch((errors: UserError) => {\n        if (formNode.value) setErrors(formNode.value, errors)\n      })\n  }\n\n  afterSubmitHandling(submitResult, values)\n}\n\nlet formUpdaterQueryHandler: QueryHandler<\n  FormUpdaterQuery,\n  FormUpdaterQueryVariables\n>\n\nconst triggerFormUpdater = (options?: FormUpdaterOptions) => {\n  handlesFormUpdater('manual', undefined, undefined, options)\n}\n\nconst delayedSubmitPlugin = (node: FormKitNode) => {\n  node.on('message-removed', async ({ payload }) => {\n    if (\n      (payload.key === 'formUpdaterProcessing' ||\n        payload.key === 'uploadProcessing') &&\n      delayedSubmit\n    ) {\n      // We need to wait on the \"next tick\", so that the validation for updated fields is ready.\n      setTimeout(() => {\n        delayedSubmit = false\n        node.submit()\n      }, 0)\n    }\n  })\n\n  return false\n}\n\nconst localFormKitPlugins = computed(() => {\n  return [delayedSubmitPlugin, ...(props.formKitPlugins || [])]\n})\n\nconst formConfig = computed(() => {\n  return {\n    validationVisibility: props.validationVisibility,\n  }\n})\n\n// Define the additional component library for the used components which are not form fields.\nconst additionalComponentLibrary = {\n  FormLayout: markRaw(FormLayout),\n  FormGroup: markRaw(FormGroup),\n  ...props.schemaComponentLibrary,\n}\n\n// Define the static schema, which will be filled with the real fields from the `schemaData`.\nconst staticSchema = ref<FormKitSchemaNode[]>([])\n\nconst fixedAndSkippedFields: string[] = []\n\nconst schemaData = reactive<ReactiveFormSchemData>({\n  fields: {},\n  flags: {},\n  values,\n  // Helper function to translate directly with the formkit syntax.\n  // Wrapper is neded, because of unexpected side effects.\n  t: (\n    source: Parameters<I18N['t']>[0],\n    ...args: Array<Parameters<I18N['t']>[1]>\n  ) => {\n    return i18n.t(source, ...args)\n  },\n  markup,\n  ...props.schemaData,\n})\n\nconst internalFieldCamelizeName: Record<string, string> = {}\n\nconst getInternalId = (item?: { id?: string; internalId?: number }) => {\n  if (!item) return undefined\n  if (item.internalId) return item.internalId\n  if (!item.id) return undefined\n  return parseGraphqlId(item.id).id\n}\n\nlet initialEntityObjectAttributeMap: Record<string, FormFieldValue> = {}\nconst setInitialEntityObjectAttributeMap = (\n  initialEntityObject = props.initialEntityObject,\n) => {\n  if (isEmpty(initialEntityObject)) return\n\n  const { objectAttributeValues } = initialEntityObject\n\n  if (!objectAttributeValues) return\n\n  // Reduce object attribute values to flat structure\n  initialEntityObjectAttributeMap =\n    objectAttributeValues.reduce((acc: Record<string, FormFieldValue>, cur) => {\n      const { attribute } = cur\n\n      if (!attribute || !attribute.name) return acc\n\n      acc[attribute.name] = cur.value\n      return acc\n    }, {}) || {}\n}\n\n// Initialize the initial entity object attribute map during the setup in a static way.\n// It will maybe be updated later, when the resetForm is used with a different entity object.\nsetInitialEntityObjectAttributeMap()\n\nconst getInitialEntityObjectValue = (\n  fieldName: string,\n  initialEntityObject = props.initialEntityObject,\n): FormFieldValue => {\n  if (isEmpty(initialEntityObject)) return undefined\n\n  let value: FormFieldValue\n  if (relationFieldBelongsToObjectField[fieldName]) {\n    const belongsToObject =\n      initialEntityObject[relationFieldBelongsToObjectField[fieldName]]\n\n    if (!belongsToObject) return undefined\n\n    if ('edges' in belongsToObject) {\n      value = edgesToArray(\n        belongsToObject as { edges?: { node: { internalId: number } }[] },\n      ).map((item) => getInternalId(item))\n    } else {\n      value = getInternalId(belongsToObject)\n    }\n  }\n\n  if (!value) {\n    const targetFieldName = internalFieldCamelizeName[fieldName] || fieldName\n\n    value =\n      targetFieldName in initialEntityObjectAttributeMap\n        ? initialEntityObjectAttributeMap[targetFieldName]\n        : initialEntityObject[targetFieldName]\n  }\n\n  return value\n}\n\nconst getResetFormValues = (\n  rootNode: FormKitNode,\n  values?: FormValues,\n  object?: EntityObject,\n  groupNode?: FormKitNode,\n  resetDirty = true,\n) => {\n  const resetValues: FormValues = {}\n  const dirtyNodes: FormKitNode[] = []\n  const dirtyValues: FormValues = {}\n\n  const setResetFormValue = (\n    name: string,\n    value: FormFieldValue,\n    parentName?: string,\n  ) => {\n    if (parentName) {\n      resetValues[parentName] ||= {}\n      ;(resetValues[parentName] as Record<string, FormFieldValue>)[name] = value\n      return\n    }\n\n    resetValues[name] = value\n  }\n\n  const checkValue = (\n    name: string,\n    values: FormValues,\n    parentName?: string,\n  ) => {\n    if (name in values) {\n      setResetFormValue(name, values[name], parentName)\n\n      return true\n    }\n    if (parentName && parentName in values && values[parentName]) {\n      const value = (values[parentName] as Record<string, FormFieldValue>)[name]\n\n      setResetFormValue(name, value, parentName)\n\n      return true\n    }\n\n    return false\n  }\n\n  const checkObjectValue = (\n    name: string,\n    object: EntityObject,\n    parentName?: string,\n  ) => {\n    const objectValue = getInitialEntityObjectValue(name, object)\n    if (objectValue !== undefined) {\n      setResetFormValue(name, objectValue, parentName)\n\n      return true\n    }\n\n    return false\n  }\n\n  Object.entries(schemaData.fields).forEach(([field, { props }]) => {\n    const formElement = props.id ? getNode(props.id) : getNodeByName(props.name)\n\n    if (!formElement) return\n\n    let parentName = ''\n    if (formElement.parent && formElement.parent.name !== rootNode.name) {\n      parentName = formElement.parent.name\n    }\n\n    // Do not use the parentName, when we are in group node reset context.\n    const groupName = groupNode?.name\n    if (groupName) {\n      if (parentName !== groupName) return\n      parentName = ''\n    }\n\n    if (!resetDirty && formElement.context?.state.dirty) {\n      dirtyNodes.push(formElement)\n      dirtyValues[field] = formElement._value as FormFieldValue\n    }\n\n    // We should only do something related to the given values, when something was given.\n    if (values && checkValue(field, values, parentName)) return\n\n    if (object) {\n      checkObjectValue(field, object, parentName)\n    }\n  })\n\n  return {\n    dirtyNodes,\n    dirtyValues,\n    resetValues,\n  }\n}\n\nconst resetForm = (\n  data: FormResetData = {},\n  options: FormResetOptions = {},\n) => {\n  if (!formNode.value) return\n\n  const { object, values } = data\n  const { resetDirty = true, resetFlags = true, groupNode } = options\n\n  formResetRunning.value = true\n\n  if (resetFlags) {\n    schemaData.flags = {}\n  }\n\n  const rootNode = formNode.value\n\n  if (object) {\n    setInitialEntityObjectAttributeMap(object)\n    setInitialEntityObjectToContext(rootNode, object)\n  }\n\n  const { dirtyNodes, dirtyValues, resetValues } = getResetFormValues(\n    rootNode,\n    values,\n    object,\n    groupNode,\n    resetDirty,\n  )\n\n  ;(groupNode || rootNode)?.reset(\n    Object.keys(resetValues).length ? resetValues : undefined,\n  )\n\n  // keep dirty nodes as dirty\n  dirtyNodes.forEach((node) => {\n    node.input(dirtyValues[node.name], false)\n  })\n\n  formResetRunning.value = false\n\n  // Trigger the formUpdater, when the reset is done.\n  handlesFormUpdater(resetDirty ? 'form-reset' : 'form-refresh')\n}\n\nconst localInitialValues: FormValues = { ...props.initialValues }\n\nconst initializeFieldRelation = (\n  fieldName: string,\n  relation: FormSchemaField['relation'],\n  belongsToObjectField?: string,\n) => {\n  if (relation) {\n    relationFields.push({\n      name: fieldName,\n      relation: relation.type,\n      filterIds: relation.filterIds,\n    })\n  }\n\n  if (belongsToObjectField) {\n    relationFieldBelongsToObjectField[fieldName] = belongsToObjectField\n  }\n}\n\nconst setInternalField = (fieldName: string, internal: boolean) => {\n  if (!internal) return\n\n  internalFieldCamelizeName[fieldName] = camelize(fieldName)\n}\n\nconst updateSchemaLink = (\n  specificProps: FormFieldAdditionalProps,\n  fieldName: string,\n) => {\n  // native fields don't have link attribute, and we don't have a way to get rendered link from graphql\n  const values = (props.initialEntityObject?.objectAttributeValues ||\n    []) as ObjectAttributeValue[]\n  const attribute = values.find(({ attribute }) => attribute.name === fieldName)\n  if (attribute?.renderedLink) {\n    specificProps.link = attribute.renderedLink\n  }\n}\n\nconst updateSchemaDataField = (\n  field: FormSchemaField | SetRequired<Partial<FormSchemaField>, 'name'>,\n) => {\n  const {\n    show,\n    updateFields,\n    relation,\n    if: staticCondition,\n    props: specificProps = {},\n    ...fieldProps\n  } = field\n  const showWithStaticCondition = Boolean(\n    staticCondition || schemaData.fields[field.name]?.staticCondition,\n  )\n  const showField =\n    show ??\n    schemaData.fields[field.name]?.show ??\n    (showWithStaticCondition ? undefined : true)\n\n  // Special handling for the disabled prop, so that the form can handle also\n  // the disable state from outside.\n  if ('disabled' in fieldProps && !fieldProps.disabled) {\n    fieldProps.disabled = undefined\n  }\n\n  updateSchemaLink(fieldProps, field.name)\n\n  if (schemaData.fields[field.name]) {\n    schemaData.fields[field.name] = {\n      show: showField,\n      updateFields: !!updateFields,\n      staticCondition: showWithStaticCondition,\n      props: Object.assign(\n        schemaData.fields[field.name].props,\n        fieldProps,\n        specificProps,\n      ),\n    }\n  } else {\n    initializeFieldRelation(\n      field.name,\n      relation,\n      specificProps?.belongsToObjectField,\n    )\n\n    setInternalField(field.name, Boolean(fieldProps.internal))\n\n    const combinedFieldProps = Object.assign(fieldProps, specificProps)\n\n    // Select the correct initial value (at this time localInitialValues has not already the information\n    // from the initial entity object, so we need to check it manually).\n    if (field.name in localInitialValues) {\n      combinedFieldProps.value = localInitialValues[field.name]\n    } else {\n      const initialEntityOjectValue = getInitialEntityObjectValue(field.name)\n      combinedFieldProps.value =\n        initialEntityOjectValue !== undefined\n          ? initialEntityOjectValue\n          : combinedFieldProps.value\n    }\n\n    // Save current initial value for later usage.\n    localInitialValues[field.name] = combinedFieldProps.value\n\n    schemaData.fields[field.name] = {\n      show: showField,\n      updateFields: !!updateFields,\n      staticCondition: showWithStaticCondition,\n      props: combinedFieldProps,\n    }\n  }\n}\n\nconst updateChangedFields = (\n  changedFields: Record<string, Partial<FormSchemaField>>,\n) => {\n  const handleUpdatedInitialFieldValue = (\n    fieldName: string,\n    value: FormFieldValue,\n    directly: boolean,\n    field: Partial<FormSchemaField>,\n  ) => {\n    if (value === undefined) return\n\n    if (directly) {\n      field.value = value\n    } else if (!formKitInitialNodesSettled.value) {\n      changeInitialValue.set(fieldName, value)\n    }\n  }\n\n  Object.keys(changedFields).forEach(async (fieldName) => {\n    if (!schemaData.fields[fieldName]) return\n\n    const { initialValue, value, ...changedFieldProps } =\n      changedFields[fieldName]\n\n    const field: SetRequired<Partial<FormSchemaField>, 'name'> = {\n      ...changedFieldProps,\n      name: fieldName,\n    }\n\n    const showField = !schemaData.fields[fieldName].show && field.show\n    const staticShowCondition = schemaData.fields[fieldName].staticCondition\n\n    const pendingValueUpdate =\n      !showField &&\n      value !== undefined &&\n      !isEqual(value, values.value[fieldName])\n\n    if (pendingValueUpdate) {\n      field.pendingValueUpdate = true\n    }\n\n    // This happens for the initial updater, when the form is not settled yet or the field was not rendered yet.\n    // In this case we need to remember the changes and do it afterwards after the form is settled the first time.\n    // Sometimes the value from the server is the \"real\" initial value, for this the `initialValue` can be used.\n    handleUpdatedInitialFieldValue(\n      fieldName,\n      value ?? initialValue,\n      showField ||\n        initialValue !== undefined ||\n        (staticShowCondition && !getNodeByName(fieldName)),\n      field,\n    )\n\n    // When a field will be visible with the update call, we need to wait before on a settled form, before we\n    // continue (so that we have all values present inside the form).\n    // This situtation can happen, when the form is used very fast.\n    if (\n      formKitInitialNodesSettled.value &&\n      !schemaData.fields[fieldName].show &&\n      field.show &&\n      !formNode.value?.isSettled\n    ) {\n      await formNode.value?.settled\n    }\n\n    updaterChangedFields.add(fieldName)\n    updateSchemaDataField(field)\n\n    if (!formKitInitialNodesSettled.value) return\n\n    if (pendingValueUpdate) {\n      const node = field.id ? getNode(field.id) : getNodeByName(fieldName)\n\n      // Update the value in the next tick, so that all other props are already updated.\n      nextTick(() => {\n        node?.input(value, false)\n      })\n    }\n  })\n\n  nextTick(() => {\n    updaterChangedFields.clear()\n    formNode.value?.store.remove('formUpdaterProcessing')\n  })\n}\n\nconst formHandlerExecution: Record<\n  FormHandlerExecution,\n  FormHandlerFunction[]\n> = {\n  [FormHandlerExecution.Initial]: [],\n  [FormHandlerExecution.InitialSettled]: [],\n  [FormHandlerExecution.FieldChange]: [],\n}\nif (props.handlers) {\n  props.handlers.forEach((handler) => {\n    Object.values(FormHandlerExecution).forEach((execution) => {\n      if (handler.execution.includes(execution)) {\n        formHandlerExecution[execution].push(handler.callback)\n      }\n    })\n  })\n}\n\nconst executeFormHandler = (\n  execution: FormHandlerExecution,\n  currentValues: FormValues,\n  changedField?: ChangedField,\n  formUpdaterData?: FormUpdaterQuery['formUpdater'],\n) => {\n  if (formHandlerExecution[execution].length === 0) return\n\n  formHandlerExecution[execution].forEach((handler) => {\n    handler(\n      execution,\n      {\n        changeFields,\n        updateSchemaDataField,\n        schemaData,\n      },\n      {\n        formNode: formNode.value,\n        getNodeByName,\n        findNodeByName,\n        values: currentValues,\n        changedField,\n        initialEntityObject: props.initialEntityObject,\n        formUpdaterData,\n      },\n    )\n  })\n}\n\nconst formUpdaterVariables = shallowRef<FormUpdaterQueryVariables>()\nlet nextFormUpdaterVariables: Maybe<FormUpdaterQueryVariables>\nconst executeFormUpdaterRefetch = () => {\n  if (!nextFormUpdaterVariables) return\n\n  formNode.value?.store.set(\n    createMessage({\n      blocking: true,\n      key: 'formUpdaterProcessing',\n      value: true,\n      visible: false,\n    }),\n  )\n\n  formUpdaterVariables.value = nextFormUpdaterVariables\n\n  // Reset the next variables so that it's not triggered a second time.\n  nextFormUpdaterVariables = null\n}\n\nconst handlesFormUpdater = (\n  trigger: FormUpdaterTrigger,\n  changedField?: FormUpdaterChangedFieldInput,\n  changedFieldNode?: FormKitNode,\n  options?: FormUpdaterOptions,\n) => {\n  if (!props.formUpdaterId || !formUpdaterQueryHandler) return\n  // When formUpdaterInitial is set, trigger only on initial rendering and when the form was reseted.\n  if (\n    trigger !== 'manual' &&\n    trigger !== 'form-reset' &&\n    trigger !== 'form-refresh' &&\n    (!changedField || props.formUpdaterInitialOnly)\n  )\n    return\n\n  const meta: FormUpdaterMetaInput = {\n    // We need a unique requestId, so that the query will always be executed on changes, also when the variables\n    // are the same until the last request, because it could be that core workflow is setting a value back.\n    requestId: getUuid(),\n    formId,\n    additionalData: {\n      ...props.formUpdaterAdditionalParams,\n      ...options?.additionalParams,\n    },\n  }\n\n  if (options?.includeDirtyFields) {\n    const dirtyFields: string[] = []\n\n    Object.entries(schemaData.fields).forEach(([field, { props }]) => {\n      const formElement = props.id\n        ? getNode(props.id)\n        : getNodeByName(props.name)\n\n      if (!formElement) return\n\n      if (formElement.context?.state.dirty) {\n        dirtyFields.push(field)\n      }\n    })\n\n    meta.dirtyFields = dirtyFields\n  }\n\n  const data: FormValues = {\n    ...values.value,\n  }\n\n  if (trigger === 'form-reset') {\n    meta.reset = true\n  } else if (changedField) {\n    meta.changedField = changedField\n\n    const parentName = changedFieldNode?.parent?.name\n\n    // Currently we are only supporting one level.\n    if (\n      formNode.value &&\n      parentName &&\n      parentName !== formNode.value.name &&\n      (!props.flattenFormGroups ||\n        !props.flattenFormGroups.includes(parentName))\n    ) {\n      data[parentName] ||= {}\n      ;(data[parentName] as Record<string, FormFieldValue>)[changedField.name] =\n        changedField.newValue\n    } else {\n      data[changedField.name] = changedField.newValue\n    }\n  }\n\n  // We mark this as raw, because we want no deep reactivity on the form updater query variables.\n  nextFormUpdaterVariables = markRaw({\n    id: props.initialEntityObject?.id,\n    formUpdaterId: props.formUpdaterId,\n    data,\n    meta,\n    relationFields,\n  })\n\n  if (trigger !== 'blur') executeFormUpdaterRefetch()\n}\n\nconst previousValues = new WeakMap<FormKitNode, FormFieldValue>()\nconst changedInputValueHandling = (inputNode: FormKitNode) => {\n  inputNode.on('commit', ({ payload: newValue, origin: node }) => {\n    const oldValue = previousValues.get(node)\n    if (isEqual(newValue, oldValue)) return\n\n    if (!formKitInitialNodesSettled.value || formResetRunning.value) {\n      previousValues.set(node, cloneDeep(newValue))\n      return\n    }\n\n    if (\n      inputNode.props.triggerFormUpdater &&\n      !updaterChangedFields.has(node.name)\n    ) {\n      handlesFormUpdater(\n        inputNode.props.formUpdaterTrigger,\n        {\n          name: node.name,\n          newValue,\n          oldValue,\n        },\n        node,\n      )\n    }\n\n    emit('changed', node.name, newValue, oldValue)\n    formNode.value?.emit(`changed:${node.name}`, {\n      newValue,\n      oldValue,\n      fieldNode: node,\n    })\n    executeFormHandler(FormHandlerExecution.FieldChange, values.value, {\n      name: node.name,\n      newValue,\n      oldValue,\n    })\n\n    previousValues.set(node, cloneDeep(newValue))\n    updaterChangedFields.delete(node.name)\n  })\n\n  inputNode.on('blur', async () => {\n    if (inputNode.props.formUpdaterTrigger !== 'blur') return\n\n    if (!formNode.value?.isSettled) await formNode.value?.settled\n\n    if (nextFormUpdaterVariables) executeFormUpdaterRefetch()\n  })\n\n  inputNode.hook.message((payload: FormKitMessageProps, next) => {\n    if (payload.key === 'submitted' && formUpdaterProcessing.value) {\n      payload.value = false\n    }\n    return next(payload)\n  })\n\n  return false\n}\n\nconst buildStaticSchema = () => {\n  const { getFormFieldSchema, getFormFieldsFromScreen } =\n    useObjectAttributeFormFields(fixedAndSkippedFields)\n\n  const buildFormKitField = (\n    field: FormSchemaField,\n  ): FormKitSchemaComponent => {\n    const fieldId = field.id || getNodeId(formId, field.name)\n\n    const plugins = [changedInputValueHandling]\n\n    if (field.plugins) {\n      plugins.push(...field.plugins)\n    }\n\n    return {\n      $cmp: 'FormKit',\n      if: field.if ? field.if : `$fields.${field.name}.show`,\n      bind: `$fields.${field.name}.props`,\n      props: {\n        type: field.type,\n        key: fieldId,\n        name: field.name,\n        id: fieldId,\n        formId,\n        plugins,\n        validationMessages: field.validationMessages,\n        validationRules: field.validationRules,\n        triggerFormUpdater: field.triggerFormUpdater ?? !!props.formUpdaterId,\n      },\n    }\n  }\n\n  const getLayoutType = (\n    layoutNode: FormSchemaLayout,\n  ): FormKitSchemaDOMNode | FormKitSchemaComponent => {\n    let layoutField: FormKitSchemaDOMNode | FormKitSchemaComponent\n\n    if ('component' in layoutNode) {\n      layoutField = {\n        $cmp: layoutNode.component,\n        ...(layoutNode.if && { if: layoutNode.if }),\n        props: layoutNode.props,\n      }\n    } else {\n      layoutField = {\n        $el: layoutNode.element,\n        ...(layoutNode.if && { if: layoutNode.if }),\n        attrs: layoutNode.attrs,\n      }\n    }\n\n    if (layoutNode.if) {\n      layoutField.if = layoutNode.if\n    }\n\n    return layoutField\n  }\n\n  type ResolveFormSchemaNode = Exclude<FormSchemaNode, string>\n  type ResolveFormKitSchemaNode = Exclude<FormKitSchemaNode, string>\n\n  const resolveSchemaNode = (\n    node: ResolveFormSchemaNode,\n  ): Maybe<ResolveFormKitSchemaNode | ResolveFormKitSchemaNode[]> => {\n    if ('isLayout' in node && node.isLayout) {\n      return getLayoutType(node)\n    }\n\n    if ('isGroupOrList' in node && node.isGroupOrList) {\n      const nodeId = `${node.name}-${formId}`\n\n      return {\n        $cmp: 'FormKit',\n        ...(node.if && { if: node.if }),\n        props: {\n          type: node.type,\n          name: node.name,\n          id: nodeId,\n          key: node.name,\n          plugins: node.plugins,\n        },\n      }\n    }\n\n    if ('object' in node && getFormFieldSchema && getFormFieldsFromScreen) {\n      if ('name' in node && node.name && !node.type) {\n        const { screen, object, ...fieldNode } = node\n\n        const resolvedField = getFormFieldSchema(fieldNode.name, object, screen)\n\n        if (!resolvedField) return null\n\n        node = {\n          ...resolvedField,\n          ...fieldNode,\n        } as FormSchemaField\n      } else if ('screen' in node && !('name' in node)) {\n        const resolvedFields = getFormFieldsFromScreen(node.screen, node.object)\n        const formKitFields: ResolveFormKitSchemaNode[] = []\n        resolvedFields.forEach((screenField) => {\n          updateSchemaDataField(screenField)\n          formKitFields.push(buildFormKitField(screenField))\n        })\n\n        return formKitFields\n      }\n    }\n\n    updateSchemaDataField(node as FormSchemaField)\n    return buildFormKitField(node as FormSchemaField)\n  }\n\n  const resolveSchema = (schema: FormSchemaNode[] = props.schema) => {\n    return schema.reduce((resolvedSchema: FormKitSchemaNode[], node) => {\n      if (typeof node === 'string') {\n        resolvedSchema.push(node)\n        return resolvedSchema\n      }\n\n      const resolvedNode = resolveSchemaNode(node)\n\n      if (!resolvedNode) return resolvedSchema\n\n      if ('children' in node) {\n        const childrens = Array.isArray(node.children)\n          ? [...resolveSchema(node.children)]\n          : node.children\n\n        resolvedSchema.push({\n          ...(resolvedNode as Exclude<FormKitSchemaNode, string>),\n          children: childrens,\n        })\n        return resolvedSchema\n      }\n\n      if (Array.isArray(resolvedNode)) {\n        resolvedSchema.push(...resolvedNode)\n      } else {\n        resolvedSchema.push(resolvedNode)\n      }\n\n      return resolvedSchema\n    }, [])\n  }\n\n  staticSchema.value = resolveSchema()\n}\n\nwatchOnce(formKitInitialNodesSettled, () => {\n  watch(\n    changeFields,\n    (newValue) => {\n      updateChangedFields(newValue)\n    },\n    {\n      deep: true,\n    },\n  )\n})\n\nwatch(\n  () => props.schemaData,\n  () => Object.assign(schemaData, props.schemaData),\n  {\n    deep: true,\n  },\n)\n\nconst setFormSchemaInitialized = () => {\n  if (!formSchemaInitialized.value) {\n    formSchemaInitialized.value = true\n  }\n}\n\nconst { notify, removeNotification } = useNotifications()\n\nlet formUpdaterQueryLoadingTimeoutId: NodeJS.Timeout | null\n\nconst clearFormUpdaterQueryLoadingTimeout = () => {\n  if (!formUpdaterQueryLoadingTimeoutId) return\n\n  clearTimeout(formUpdaterQueryLoadingTimeoutId)\n  formUpdaterQueryLoadingTimeoutId = null\n}\n\nconst cleanupFormUpdaterAutosaveNotification = () => {\n  removeNotification('form-updater-autosave')\n  clearFormUpdaterQueryLoadingTimeout()\n}\n\nconst handleFormUpdaterAutosaveNotification = () => {\n  if (\n    !formUpdaterVariables.value?.meta.additionalData?.taskbarId &&\n    !formUpdaterVariables.value?.meta.additionalData?.applyTaskbarState\n  )\n    return\n\n  // Clean up previous notification and timeout.\n  cleanupFormUpdaterAutosaveNotification()\n\n  const formUpdaterQueryLoading = formUpdaterQueryHandler.loading()\n\n  watch(formUpdaterQueryLoading, (isLoading) => {\n    if (!isLoading) {\n      cleanupFormUpdaterAutosaveNotification()\n      return\n    }\n\n    // Clear previous timeout.\n    clearFormUpdaterQueryLoadingTimeout()\n\n    formUpdaterQueryLoadingTimeoutId = setTimeout(() => {\n      // Show info notification if the request takes longer than a second.\n      notify({\n        id: 'form-updater-autosave',\n        message: __('Autosave in progress…'),\n        type: NotificationTypes.Info,\n        persistent: true,\n      })\n\n      // Show warning notification if the request takes longer than five seconds.\n      formUpdaterQueryLoadingTimeoutId = setTimeout(() => {\n        notify({\n          id: 'form-updater-autosave',\n          message: __('Autosaving is taking longer than expected…'),\n          type: NotificationTypes.Warn,\n          persistent: true,\n        })\n      }, 4000)\n    }, 1000)\n  })\n}\n\nconst formUpdaterScope = effectScope()\n\nonBeforeUnmount(() => {\n  if (formUpdaterScope.active) formUpdaterScope.stop()\n  cleanupFormUpdaterAutosaveNotification()\n})\n\nconst initializeFormSchema = () => {\n  buildStaticSchema()\n\n  if (props.formUpdaterId) {\n    formUpdaterVariables.value = markRaw({\n      id: props.initialEntityObject?.id,\n      formUpdaterId: props.formUpdaterId,\n      data: localInitialValues,\n      meta: {\n        initial: true,\n        additionalData: props.formUpdaterAdditionalParams,\n        formId,\n      },\n      relationFields,\n    })\n\n    formUpdaterScope.run(() => {\n      formUpdaterQueryHandler = new QueryHandler(\n        useFormUpdaterQuery(\n          formUpdaterVariables as Ref<FormUpdaterQueryVariables>,\n          {\n            context: {\n              batch: {\n                active: false,\n              },\n              websocket: {\n                active: true,\n              },\n            },\n            fetchPolicy: 'no-cache',\n          },\n        ),\n      )\n    })\n\n    handleFormUpdaterAutosaveNotification()\n\n    formUpdaterQueryHandler.onResult((queryResult) => {\n      // Execute the form handler function so that they can manipulate the form updater result.\n      if (!formSchemaInitialized.value) {\n        executeFormHandler(\n          FormHandlerExecution.Initial,\n          localInitialValues,\n          undefined,\n          queryResult?.data?.formUpdater,\n        )\n      }\n\n      if (queryResult?.data?.formUpdater) {\n        Object.assign(schemaData.flags, queryResult.data.formUpdater.flags)\n\n        updateChangedFields(\n          changeFields.value\n            ? merge(queryResult.data.formUpdater.fields, changeFields.value)\n            : queryResult.data.formUpdater.fields,\n        )\n      }\n\n      setFormSchemaInitialized()\n    })\n  } else {\n    executeFormHandler(FormHandlerExecution.Initial, localInitialValues)\n    if (changeFields.value) updateChangedFields(changeFields.value)\n\n    setFormSchemaInitialized()\n  }\n}\n\n// TODO: maybe we should react on schema changes and rebuild the static schema with a new form-id and re-rendering of\n// the complete form (= use the formId as the key for the whole form to trigger the re-rendering of the component...)\nif (props.schema) {\n  showInitialLoadingAnimation.value = true\n\n  if (props.useObjectAttributes) {\n    // TODO: rebuild schema, when object attributes\n    // was changed from outside(not such important,\n    // because we have currently the reload solution like in the desktop view).\n    if (props.objectAttributeSkippedFields) {\n      fixedAndSkippedFields.push(...props.objectAttributeSkippedFields)\n    }\n\n    const objectAttributeObjects: EnumObjectManagerObjects[] = []\n\n    const addObjectAttributeToObjects = (object: EnumObjectManagerObjects) => {\n      if (objectAttributeObjects.includes(object)) return\n\n      objectAttributeObjects.push(object)\n    }\n\n    const detectObjectAttributeObjects = (\n      schema: FormSchemaNode[] = props.schema,\n    ) => {\n      schema.forEach((item) => {\n        if (typeof item === 'string') return\n\n        if ('object' in item) {\n          if ('name' in item && item.name && !item.type) {\n            fixedAndSkippedFields.push(item.name)\n          }\n\n          addObjectAttributeToObjects(item.object)\n        }\n\n        if ('children' in item && Array.isArray(item.children)) {\n          detectObjectAttributeObjects(item.children)\n        }\n      })\n    }\n\n    detectObjectAttributeObjects()\n\n    // We need only to fetch object attributes, when there are used in the given schema.\n    if (objectAttributeObjects.length > 0) {\n      const { objectAttributesLoading } = useObjectAttributeLoadFormFields(\n        objectAttributeObjects,\n      )\n\n      const unwatchTriggerFormInitialize = watch(\n        objectAttributesLoading,\n        (loading) => {\n          if (!loading) {\n            nextTick(() => unwatchTriggerFormInitialize())\n            initializeFormSchema()\n          }\n        },\n        { immediate: true },\n      )\n    } else {\n      initializeFormSchema()\n    }\n  } else {\n    initializeFormSchema()\n  }\n}\n\nconst classMap = getFormClasses()\n\ndefineExpose({\n  formNode,\n  formInitialSettled,\n  formId,\n  values,\n  flags: schemaData.flags,\n  updateChangedFields,\n  updateSchemaDataField,\n  getNodeByName,\n  findNodeByName,\n  resetForm,\n  triggerFormUpdater,\n})\n</script>\n\n<script lang=\"ts\">\nexport default {\n  inheritAttrs: false,\n}\n</script>\n\n<template>\n  <div\n    v-if=\"debouncedShowInitialLoadingAnimation\"\n    class=\"flex items-center justify-center\"\n  >\n    <CommonIcon :class=\"classMap.loading\" name=\"loading\" animation=\"spin\" />\n  </div>\n  <FormKit\n    v-if=\"\n      hasSchema &&\n      ((formSchemaInitialized && Object.keys(schemaData.fields).length > 0) ||\n        $slots.default)\n    \"\n    v-bind=\"$attrs\"\n    :id=\"id\"\n    type=\"form\"\n    novalidate\n    :config=\"formConfig\"\n    :form-class=\"localClass\"\n    :actions=\"false\"\n    :incomplete-message=\"false\"\n    :plugins=\"localFormKitPlugins\"\n    :sections-schema=\"formKitSectionsSchema\"\n    :disabled=\"disabled\"\n    @node=\"setFormNode\"\n    @submit=\"onSubmit\"\n    @submit-raw=\"onSubmitRaw\"\n  >\n    <FormKitMessages\n      :sections-schema=\"{\n        messages: {\n          $el: 'div',\n        },\n        message: {\n          $el: undefined,\n          $cmp: 'CommonAlert',\n          props: {\n            id: `$id + '-' + $message.key`,\n            key: '$message.key',\n            variant: {\n              if: '$message.type == error || $message.type == validation',\n              then: 'danger',\n              else: '$message.type',\n            },\n          },\n          slots: {\n            default: '$message.value',\n          },\n        },\n      }\"\n    />\n\n    <slot name=\"before-fields\" />\n\n    <slot\n      name=\"default\"\n      :schema=\"staticSchema\"\n      :data=\"schemaData\"\n      :library=\"additionalComponentLibrary\"\n    >\n      <div\n        v-show=\"\n          formKitInitialNodesSettled && !debouncedShowInitialLoadingAnimation\n        \"\n        ref=\"form\"\n        :class=\"formClass\"\n      >\n        <FormKitSchema\n          :schema=\"staticSchema\"\n          :data=\"schemaData\"\n          :library=\"additionalComponentLibrary\"\n        />\n      </div>\n    </slot>\n    <slot name=\"after-fields\" />\n  </FormKit>\n</template>\n"],"names":["useObjectAttributeFormFields","skippedFields","getObjectAttributesForObject","useObjectAttributesStore","getFormFieldSchema","name","object","screen","objectAttributesObject","resolvedField","screenConfig","_a","transformResolvedFieldForScreen","screens","formFields","attributeName","formField","useObjectAttributeLoadFormFields","objectAttributeObjects","objectAttributesByObject","useObjectAttributes","computed","loading","props","__props","columnClass","FormUpdaterDocument","gql","useFormUpdaterQuery","variables","options","VueApolloComposable.useQuery","__default__","formId","getUuid","slots","useSlots","hasSchema","formSchemaInitialized","ref","log","localClass","toRef","emit","__emit","showInitialLoadingAnimation","debouncedShowInitialLoadingAnimation","refDebounced","formKitInitialNodesSettled","formInitialSettled","formResetRunning","formNode","formElement","useTemplateRef","changeFields","updaterChangedFields","changeInitialValue","getNodeByName","id","getFormkitFieldNode","findNodeByName","autofocusFirstInput","node","nextTick","firstInput","getFirstFocusableElement","formName","testFlags","setInitialEntityObjectToContext","setFormNode","value","fieldName","executeFormHandler","FormHandlerExecution","values","formNodeContext","getFlatValues","formGroups","flatValues","formGroup","relationFields","relationFieldBelongsToObjectField","formUpdaterProcessing","_b","uploadProcessing","delayedSubmit","onSubmitRaw","afterSubmitReset","afterSubmitHandling","submitReturn","schemaData","isObject","onSubmit","submitResult","result","errors","setErrors","formUpdaterQueryHandler","triggerFormUpdater","handlesFormUpdater","delayedSubmitPlugin","payload","localFormKitPlugins","formConfig","additionalComponentLibrary","markRaw","FormLayout","FormGroup","staticSchema","fixedAndSkippedFields","reactive","source","args","i18n","markup","internalFieldCamelizeName","getInternalId","item","parseGraphqlId","initialEntityObjectAttributeMap","setInitialEntityObjectAttributeMap","initialEntityObject","isEmpty","objectAttributeValues","acc","cur","attribute","getInitialEntityObjectValue","belongsToObject","edgesToArray","targetFieldName","getResetFormValues","rootNode","groupNode","resetDirty","resetValues","dirtyNodes","dirtyValues","setResetFormValue","parentName","checkValue","checkObjectValue","objectValue","field","getNode","groupName","resetForm","data","resetFlags","localInitialValues","initializeFieldRelation","relation","belongsToObjectField","setInternalField","internal","camelize","updateSchemaLink","specificProps","updateSchemaDataField","show","updateFields","staticCondition","fieldProps","showWithStaticCondition","showField","combinedFieldProps","initialEntityOjectValue","updateChangedFields","changedFields","handleUpdatedInitialFieldValue","directly","initialValue","changedFieldProps","staticShowCondition","pendingValueUpdate","isEqual","formHandlerExecution","handler","execution","currentValues","changedField","formUpdaterData","formUpdaterVariables","shallowRef","nextFormUpdaterVariables","executeFormUpdaterRefetch","createMessage","trigger","changedFieldNode","meta","dirtyFields","previousValues","changedInputValueHandling","inputNode","newValue","oldValue","cloneDeep","next","buildStaticSchema","getFormFieldsFromScreen","buildFormKitField","fieldId","getNodeId","plugins","getLayoutType","layoutNode","layoutField","resolveSchemaNode","nodeId","fieldNode","resolvedFields","formKitFields","screenField","resolveSchema","schema","resolvedSchema","resolvedNode","childrens","watchOnce","watch","setFormSchemaInitialized","notify","removeNotification","useNotifications","formUpdaterQueryLoadingTimeoutId","clearFormUpdaterQueryLoadingTimeout","cleanupFormUpdaterAutosaveNotification","handleFormUpdaterAutosaveNotification","_d","_c","formUpdaterQueryLoading","isLoading","NotificationTypes","formUpdaterScope","effectScope","onBeforeUnmount","initializeFormSchema","QueryHandler","queryResult","merge","addObjectAttributeToObjects","detectObjectAttributeObjects","objectAttributesLoading","unwatchTriggerFormInitialize","classMap","getFormClasses","__expose"],"mappings":"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"}