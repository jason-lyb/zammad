{"version":3,"file":"index-DwuY2HL4.js","sources":["../../../../../node_modules/.pnpm/@formkit+drag-and-drop@0.1.6/node_modules/@formkit/drag-and-drop/index.mjs","../../../../../node_modules/.pnpm/@formkit+drag-and-drop@0.1.6/node_modules/@formkit/drag-and-drop/vue/index.mjs"],"sourcesContent":["// src/utils.ts\nfunction throttle(callback, limit) {\n  var wait = false;\n  return function(...args) {\n    if (!wait) {\n      callback.call(null, ...args);\n      wait = true;\n      setTimeout(function() {\n        wait = false;\n      }, limit);\n    }\n  };\n}\nfunction splitClass(className) {\n  return className.split(\" \").filter((x) => x);\n}\nvar isBrowser = typeof window !== \"undefined\";\nfunction addClass(els, className, omitAppendPrivateClass = false) {\n  if (!className)\n    return;\n  const classNames = splitClass(className);\n  if (!classNames.length)\n    return;\n  if (classNames.includes(\"longTouch\"))\n    return;\n  for (const node of els) {\n    if (!isNode(node) || !nodes.has(node)) {\n      node.classList.add(...classNames);\n      continue;\n    }\n    const privateClasses = [];\n    const nodeData = nodes.get(node);\n    if (!nodeData)\n      continue;\n    for (const className2 of classNames) {\n      if (!node.classList.contains(className2)) {\n        node.classList.add(className2);\n      } else if (node.classList.contains(className2) && omitAppendPrivateClass === false) {\n        privateClasses.push(className2);\n      }\n    }\n    nodeData.privateClasses = privateClasses;\n    nodes.set(node, nodeData);\n  }\n}\nfunction removeClass(els, className) {\n  if (!className)\n    return;\n  const classNames = splitClass(className);\n  if (!classNames.length)\n    return;\n  for (const node of els) {\n    if (!isNode(node)) {\n      node.classList.remove(...classNames);\n      continue;\n    }\n    const nodeData = nodes.get(node);\n    if (!nodeData)\n      continue;\n    for (const className2 of classNames) {\n      if (!nodeData.privateClasses.includes(className2)) {\n        node.classList.remove(className2);\n      }\n    }\n  }\n}\nfunction getScrollParent(childNode) {\n  let parentNode = childNode.parentNode;\n  while (parentNode !== null && parentNode.nodeType === 1 && parentNode instanceof HTMLElement) {\n    const computedStyle = window.getComputedStyle(parentNode);\n    const overflow = computedStyle.getPropertyValue(\"overflow\");\n    if (overflow === \"scroll\" || overflow === \"auto\")\n      return parentNode;\n    parentNode = parentNode.parentNode;\n  }\n  return document.documentElement;\n}\nfunction events(el, events2, fn, remove = false) {\n  events2.forEach((event) => {\n    remove ? el.removeEventListener(event, fn) : el.addEventListener(event, fn);\n  });\n}\nfunction getElFromPoint(eventData) {\n  if (!(eventData.e instanceof TouchEvent))\n    return;\n  const newX = eventData.e.touches[0].clientX;\n  const newY = eventData.e.touches[0].clientY;\n  let target = document.elementFromPoint(newX, newY);\n  if (!isNode(target))\n    return;\n  let isParent;\n  let invalidEl = true;\n  while (target && invalidEl) {\n    if (nodes.has(target) || parents.has(target)) {\n      invalidEl = false;\n      isParent = parents.has(target);\n      break;\n    }\n    target = target.parentNode;\n  }\n  if (!isParent) {\n    const targetNodeData = nodes.get(target);\n    if (!targetNodeData)\n      return;\n    const targetParentData = parents.get(target.parentNode);\n    if (!targetParentData)\n      return;\n    return {\n      node: {\n        el: target,\n        data: targetNodeData\n      },\n      parent: {\n        el: target.parentNode,\n        data: targetParentData\n      }\n    };\n  } else {\n    const parentData = parents.get(target);\n    if (!parentData)\n      return;\n    return {\n      parent: {\n        el: target,\n        data: parentData\n      }\n    };\n  }\n}\nfunction isNode(el) {\n  return el instanceof HTMLElement && el.parentNode instanceof HTMLElement;\n}\nfunction addEvents(el, events2) {\n  const abortController = new AbortController();\n  for (const eventName in events2) {\n    const handler = events2[eventName];\n    el.addEventListener(eventName, handler, {\n      signal: abortController.signal,\n      passive: false\n    });\n  }\n  return abortController;\n}\nfunction copyNodeStyle(sourceNode, targetNode, omitKeys = false) {\n  const computedStyle = window.getComputedStyle(sourceNode);\n  const omittedKeys = [\n    \"position\",\n    \"z-index\",\n    \"top\",\n    \"left\",\n    \"x\",\n    \"pointer-events\",\n    \"y\",\n    \"transform-origin\",\n    \"filter\",\n    \"-webkit-text-fill-color\"\n  ];\n  for (const key of Array.from(computedStyle)) {\n    if (omitKeys === false && key && omittedKeys.includes(key))\n      continue;\n    targetNode.style.setProperty(\n      key,\n      computedStyle.getPropertyValue(key),\n      computedStyle.getPropertyPriority(key)\n    );\n  }\n  for (const child of Array.from(sourceNode.children)) {\n    if (!isNode(child))\n      continue;\n    const targetChild = targetNode.children[Array.from(sourceNode.children).indexOf(child)];\n    copyNodeStyle(child, targetChild, omitKeys);\n  }\n}\nfunction eventCoordinates(data) {\n  return data instanceof DragEvent ? { x: data.clientX, y: data.clientY } : { x: data.touches[0].clientX, y: data.touches[0].clientY };\n}\n\n// src/plugins/multiDrag/index.ts\nvar multiDragState = {\n  selectedNodes: Array(),\n  activeNode: void 0,\n  isTouch: false\n};\nfunction multiDrag(multiDragConfig = {}) {\n  return (parent) => {\n    const parentData = parents.get(parent);\n    if (!parentData)\n      return;\n    const multiDragParentConfig = {\n      ...parentData.config,\n      multiDragConfig\n    };\n    return {\n      setup() {\n        multiDragParentConfig.handleDragstart = multiDragConfig.multiHandleDragstart || multiHandleDragstart;\n        multiDragParentConfig.handleTouchstart = multiDragConfig.multiHandleTouchstart || multiHandleTouchstart;\n        multiDragParentConfig.handleEnd = multiDragConfig.multiHandleEnd || multiHandleEnd;\n        multiDragParentConfig.reapplyDragClasses = multiDragConfig.multiReapplyDragClasses || multiReapplyDragClasses;\n        parentData.config = multiDragParentConfig;\n        multiDragParentConfig.multiDragConfig.plugins?.forEach((plugin) => {\n          plugin(parent)?.tearDown?.();\n        });\n        multiDragParentConfig.multiDragConfig.plugins?.forEach((plugin) => {\n          plugin(parent)?.setup?.();\n        });\n      },\n      tearDownNodeRemap(data) {\n        multiDragParentConfig.multiDragConfig?.plugins?.forEach((plugin) => {\n          plugin(data.parent)?.tearDownNodeRemap?.(data);\n        });\n      },\n      tearDownNode(data) {\n        multiDragParentConfig.multiDragConfig?.plugins?.forEach((plugin) => {\n          plugin(data.parent)?.tearDownNode?.(data);\n        });\n      },\n      setupNodeRemap(data) {\n        multiDragParentConfig.multiDragConfig?.plugins?.forEach((plugin) => {\n          plugin(data.parent)?.setupNodeRemap?.(data);\n        });\n      },\n      setupNode(data) {\n        multiDragParentConfig.multiDragConfig?.plugins?.forEach((plugin) => {\n          plugin(data.parent)?.setupNode?.(data);\n        });\n      }\n    };\n  };\n}\nfunction multiReapplyDragClasses(node, parentData) {\n  if (!state)\n    return;\n  const dropZoneClass = \"touchedNode\" in state ? parentData.config.multiDragConfig.touchDropZoneClass : parentData.config.multiDragConfig.dropZoneClass;\n  const draggedNodeEls = state.draggedNodes.map((x) => x.el);\n  if (!draggedNodeEls.includes(node))\n    return;\n  addClass([node], dropZoneClass, true);\n}\nfunction multiHandleEnd(data) {\n  if (!state)\n    return;\n  const isTouch = state && \"touchedNode\" in state;\n  if (isTouch && \"touchMoving\" in state && !state.touchMoving)\n    return;\n  end(data, state);\n  selectionsEnd(data, state);\n  resetState();\n}\nfunction selectionsEnd(data, state2) {\n  const multiDragConfig = data.targetData.parent.data.config.multiDragConfig;\n  const selectedClass = data.targetData.parent.data.config.selectionsConfig?.selectedClass;\n  const isTouch = state2 && \"touchedNode\" in state2;\n  if (selectedClass) {\n    removeClass(\n      multiDragState.selectedNodes.map((x) => x.el),\n      selectedClass\n    );\n  }\n  multiDragState.selectedNodes = [];\n  multiDragState.activeNode = void 0;\n  const dropZoneClass = isTouch ? multiDragConfig.selectionDropZoneClass : multiDragConfig.touchSelectionDraggingClass;\n  removeClass(\n    state2.draggedNodes.map((x) => x.el),\n    dropZoneClass\n  );\n}\nfunction multiHandleDragstart(data) {\n  if (!(data.e instanceof DragEvent))\n    return;\n  multiDragstart({\n    e: data.e,\n    targetData: data.targetData\n  });\n}\nfunction multiDragstart(data) {\n  const dragState = initDrag(data);\n  multiDragState.isTouch = false;\n  const multiDragConfig = data.targetData.parent.data.config.multiDragConfig;\n  const parentValues2 = data.targetData.parent.data.getValues(\n    data.targetData.parent.el\n  );\n  let selectedValues = multiDragState.selectedNodes.length ? multiDragState.selectedNodes.map((x) => x.data.value) : multiDragConfig.selections && multiDragConfig.selections(parentValues2, data.targetData.parent.el);\n  if (selectedValues === void 0)\n    return;\n  if (!selectedValues.includes(data.targetData.node.data.value)) {\n    selectedValues = [data.targetData.node.data.value, ...selectedValues];\n    const selectionConfig = data.targetData.parent.data.config.selectionsConfig;\n    addClass([data.targetData.node.el], selectionConfig?.selectedClass, true);\n    multiDragState.selectedNodes.push(data.targetData.node);\n  }\n  const originalZIndex = data.targetData.node.el.style.zIndex;\n  dragState.originalZIndex = originalZIndex;\n  data.targetData.node.el.style.zIndex = \"9999\";\n  if (Array.isArray(selectedValues) && selectedValues.length) {\n    const targetRect = data.targetData.node.el.getBoundingClientRect();\n    const [x, y] = [\n      data.e.clientX - targetRect.left,\n      data.e.clientY - targetRect.top\n    ];\n    stackNodes(handleSelections(data, selectedValues, dragState, x, y));\n  } else {\n    const config = data.targetData.parent.data.config;\n    dragstartClasses(\n      dragState.draggedNode.el,\n      config.draggingClass,\n      config.dropZoneClass\n    );\n  }\n}\nfunction multiHandleTouchstart(data) {\n  if (!(data.e instanceof TouchEvent))\n    return;\n  multiTouchstart({\n    e: data.e,\n    targetData: data.targetData\n  });\n}\nfunction multiTouchstart(data) {\n  const touchState = initTouch(data);\n  multiDragState.isTouch = true;\n  multiDragState.activeNode = data.targetData.node;\n  const multiDragConfig = data.targetData.parent.data.config.multiDragConfig;\n  const parentValues2 = data.targetData.parent.data.getValues(\n    data.targetData.parent.el\n  );\n  let selectedValues = [];\n  if (data.targetData.parent.data.config.selectionsConfig) {\n    selectedValues = multiDragState.selectedNodes.map((x) => x.data.value);\n  } else {\n    selectedValues = multiDragConfig.selections && multiDragConfig.selections(parentValues2, data.targetData.parent.el);\n  }\n  selectedValues = [data.targetData.node.data.value, ...selectedValues];\n  const selectionConfig = data.targetData.parent.data.config.selectionsConfig;\n  addClass([data.targetData.node.el], selectionConfig?.selectedClass, true);\n  if (Array.isArray(selectedValues) && selectedValues.length) {\n    stackNodes(\n      handleSelections(\n        data,\n        selectedValues,\n        touchState,\n        touchState.touchStartLeft,\n        touchState.touchStartTop\n      )\n    );\n  } else {\n    handleTouchedNode(data, touchState);\n  }\n  handleLongTouch(data, touchState);\n}\nfunction handleSelections(data, selectedValues, state2, x, y) {\n  for (const child of data.targetData.parent.data.enabledNodes) {\n    if (child.el === state2.draggedNode.el)\n      continue;\n    if (!selectedValues.includes(child.data.value))\n      continue;\n    state2.draggedNodes.push(child);\n  }\n  const config = data.targetData.parent.data.config.multiDragConfig;\n  const clonedEls = state2.draggedNodes.map((x2) => {\n    const el = x2.el.cloneNode(true);\n    copyNodeStyle(x2.el, el, true);\n    if (data.e instanceof DragEvent)\n      addClass([el], config.draggingClass);\n    return el;\n  });\n  setTimeout(() => {\n    if (data.e instanceof DragEvent) {\n      addClass(\n        state2.draggedNodes.map((x2) => x2.el),\n        config.dropZoneClass\n      );\n    }\n  });\n  state2.clonedDraggedEls = clonedEls;\n  return { data, state: state2, x, y };\n}\nfunction stackNodes({\n  data,\n  state: state2,\n  x,\n  y\n}) {\n  const wrapper = document.createElement(\"div\");\n  for (const el of state2.clonedDraggedEls) {\n    if (el instanceof HTMLElement)\n      el.style.pointerEvents = \"none\";\n    wrapper.append(el);\n  }\n  const { width } = state2.draggedNode.el.getBoundingClientRect();\n  wrapper.style.cssText = `\n        display: flex;\n        flex-direction: column;\n        width: ${width}px;\n        position: fixed;\n        pointer-events: none;\n        z-index: 9999;\n        left: -9999px\n      `;\n  document.body.append(wrapper);\n  if (data.e instanceof DragEvent) {\n    data.e.dataTransfer?.setDragImage(wrapper, x, y);\n    setTimeout(() => {\n      wrapper.remove();\n    });\n  } else if (\"touchedNode\" in state2) {\n    state2.touchedNode = wrapper;\n  }\n}\n\n// src/plugins/animations/index.ts\nfunction animations(animationsConfig = {}) {\n  const slideUp = [\n    {\n      transform: `translateY(${animationsConfig.yScale || 50}%)`\n    },\n    {\n      transform: `translateY(${animationsConfig.yScale || 0}%)`\n    }\n  ];\n  const slideDown = [\n    {\n      transform: `translateY(-${animationsConfig.yScale || 50}%)`\n    },\n    {\n      transform: `translateY(${animationsConfig.yScale || 0}%)`\n    }\n  ];\n  const slideLeft = [\n    {\n      transform: `translateX(${animationsConfig.xScale || 50}%)`\n    },\n    {\n      transform: `translateX(${animationsConfig.xScale || 0}%)`\n    }\n  ];\n  const slideRight = [\n    {\n      transform: `translateX(-${animationsConfig.xScale || 50}%)`\n    },\n    {\n      transform: `translateX(${animationsConfig.xScale || 0}%)`\n    }\n  ];\n  return (parent) => {\n    const parentData = parents.get(parent);\n    if (!parentData)\n      return;\n    return {\n      setup() {\n        if (document.head.querySelector(\"[data-drag-and-drop]\"))\n          return;\n      },\n      setupNodeRemap(data) {\n        if (!state)\n          return;\n        const duration = animationsConfig.duration || 150;\n        if (data.nodeData.value === state.draggedNode.data.value) {\n          switch (state.incomingDirection) {\n            case \"below\":\n              animate(data.node, slideUp, duration);\n              break;\n            case \"above\":\n              animate(data.node, slideDown, duration);\n              break;\n            case \"left\":\n              animate(data.node, slideRight, duration);\n              break;\n            case \"right\":\n              animate(data.node, slideLeft, duration);\n              break;\n          }\n          return;\n        }\n        if (!state.affectedNodes.map((x) => x.data.value).includes(data.nodeData.value))\n          return;\n        const nodeRect = data.node.getBoundingClientRect();\n        const nodeIndex = state.affectedNodes.findIndex(\n          (x) => x.data.value === data.nodeData.value\n        );\n        const draggedNodeIndex = state.draggedNode.data.index;\n        const ascendingDirection = draggedNodeIndex >= state.targetIndex;\n        let adjacentNode;\n        if (ascendingDirection) {\n          adjacentNode = state.affectedNodes[nodeIndex + 1] ? state.affectedNodes[nodeIndex + 1] : state.affectedNodes[nodeIndex - 1];\n        } else {\n          adjacentNode = state.affectedNodes[nodeIndex - 1] ? state.affectedNodes[nodeIndex - 1] : state.affectedNodes[nodeIndex + 1];\n        }\n        if (adjacentNode) {\n          const xDiff = Math.abs(\n            nodeRect.x - adjacentNode.el.getBoundingClientRect().x\n          );\n          const yDiff = Math.abs(\n            nodeRect.y - adjacentNode.el.getBoundingClientRect().y\n          );\n          if (xDiff > yDiff && ascendingDirection) {\n            animate(data.node, slideRight, duration);\n          } else if (xDiff > yDiff && !ascendingDirection) {\n            animate(data.node, slideLeft, duration);\n          }\n        } else {\n          switch (state.incomingDirection) {\n            case \"below\":\n              animate(data.node, slideDown, duration);\n              break;\n            case \"above\":\n              animate(data.node, slideUp, duration);\n              break;\n            case \"left\":\n              animate(data.node, slideLeft, duration);\n              break;\n            case \"right\":\n              animate(data.node, slideRight, duration);\n              break;\n          }\n        }\n      }\n    };\n  };\n}\nfunction animate(node, animation, duration) {\n  if (!state)\n    return;\n  state.preventEnter = true;\n  node.animate(animation, {\n    duration\n  });\n  setTimeout(() => {\n    if (!state)\n      return;\n    state.preventEnter = false;\n  }, duration);\n}\n\n// src/plugins/multiDrag/plugins/selections/index.ts\nfunction selections(selectionsConfig = {}) {\n  return (parent) => {\n    const parentData = parents.get(parent);\n    if (!parentData)\n      return;\n    return {\n      setup() {\n        parentData.config.selectionsConfig = selectionsConfig;\n        parentData.config.handleClick = selectionsConfig.handleClick || handleClick;\n        parentData.config.handleKeydown = selectionsConfig.handleKeydown || handleKeydown;\n        selectionsConfig.clickawayDeselect = selectionsConfig.clickawayDeselect === void 0 ? true : selectionsConfig.clickawayDeselect;\n        if (!selectionsConfig.clickawayDeselect)\n          return;\n        const rootAbortControllers = addEvents(parentData.config.root, {\n          click: handleRootClick.bind(null, parentData.config)\n        });\n        parentData.abortControllers[\"root\"] = rootAbortControllers;\n      },\n      tearDown() {\n        if (parentData.abortControllers.root) {\n          parentData.abortControllers.root.abort();\n        }\n      },\n      tearDownNode(data) {\n        if (data.parentData.abortControllers.selectionsNode) {\n          data.parentData.abortControllers.selectionsNode.abort();\n        }\n      },\n      setupNode(data) {\n        const config = data.parentData.config;\n        data.node.setAttribute(\"tabindex\", \"0\");\n        const abortControllers = addEvents(data.node, {\n          click: nodeEventData(config.handleClick),\n          keydown: nodeEventData(config.handleKeydown)\n        });\n        data.nodeData.abortControllers[\"selectionsNode\"] = abortControllers;\n      }\n    };\n  };\n}\nfunction handleRootClick(config) {\n  removeClass(\n    multiDragState.selectedNodes.map((x) => x.el),\n    config.selectionsConfig.selectedClass\n  );\n  multiDragState.selectedNodes = [];\n  multiDragState.activeNode = void 0;\n}\nfunction handleKeydown(data) {\n  keydown(data);\n}\nfunction handleClick(data) {\n  click(data);\n}\nfunction click(data) {\n  data.e.stopPropagation();\n  const selectionsConfig = data.targetData.parent.data.config.selectionsConfig;\n  const ctParentData = data.targetData.parent.data;\n  const selectedClass = selectionsConfig.selectedClass;\n  const targetNode = data.targetData.node;\n  let commandKey = false;\n  let shiftKey = false;\n  if (data.e instanceof MouseEvent) {\n    commandKey = data.e.ctrlKey || data.e.metaKey;\n    shiftKey = data.e.shiftKey;\n  }\n  if (shiftKey && multiDragState.isTouch === false) {\n    if (!multiDragState.activeNode) {\n      multiDragState.activeNode = {\n        el: data.targetData.node.el,\n        data: data.targetData.node.data\n      };\n      for (let x = 0; x <= data.targetData.node.data.index; x++) {\n        multiDragState.selectedNodes.push(ctParentData.enabledNodes[x]);\n        if (selectedClass) {\n          addClass([ctParentData.enabledNodes[x].el], selectedClass, true);\n        }\n      }\n    } else {\n      const [minIndex, maxIndex] = multiDragState.activeNode.data.index < data.targetData.node.data.index ? [\n        multiDragState.activeNode.data.index,\n        data.targetData.node.data.index\n      ] : [\n        data.targetData.node.data.index,\n        multiDragState.activeNode.data.index\n      ];\n      const selectedNodes = ctParentData.enabledNodes.slice(\n        minIndex,\n        maxIndex + 1\n      );\n      if (selectedNodes.length === 1) {\n        for (const node of multiDragState.selectedNodes) {\n          if (selectedClass)\n            node.el.classList.remove(selectedClass);\n        }\n        multiDragState.selectedNodes = [\n          {\n            el: data.targetData.node.el,\n            data: data.targetData.node.data\n          }\n        ];\n        multiDragState.activeNode = {\n          el: data.targetData.node.el,\n          data: data.targetData.node.data\n        };\n        if (selectedClass) {\n          data.targetData.node.el.classList.add(selectedClass);\n        }\n      }\n      for (let x = minIndex - 1; x >= 0; x--) {\n        if (multiDragState.selectedNodes.includes(ctParentData.enabledNodes[x])) {\n          multiDragState.selectedNodes = [\n            ...multiDragState.selectedNodes.filter(\n              (el) => el !== ctParentData.enabledNodes[x]\n            )\n          ];\n          if (selectedClass) {\n            addClass([ctParentData.enabledNodes[x].el], selectedClass, true);\n          }\n        } else {\n          break;\n        }\n      }\n      for (let x = maxIndex; x < ctParentData.enabledNodes.length; x++) {\n        if (multiDragState.selectedNodes.includes(ctParentData.enabledNodes[x])) {\n          multiDragState.selectedNodes = [\n            ...multiDragState.selectedNodes.filter(\n              (el) => el !== ctParentData.enabledNodes[x]\n            )\n          ];\n          if (selectedClass) {\n            removeClass([ctParentData.enabledNodes[x].el], selectedClass);\n          }\n        } else {\n          break;\n        }\n      }\n      for (const node of selectedNodes) {\n        if (!multiDragState.selectedNodes.map((x) => x.el).includes(node.el)) {\n          multiDragState.selectedNodes.push(node);\n        }\n        if (selectedClass) {\n          addClass([node.el], selectedClass, true);\n        }\n      }\n    }\n  } else if (commandKey) {\n    if (multiDragState.selectedNodes.map((x) => x.el).includes(targetNode.el)) {\n      multiDragState.selectedNodes = multiDragState.selectedNodes.filter(\n        (el) => el.el !== targetNode.el\n      );\n      if (selectedClass) {\n        removeClass([targetNode.el], selectedClass);\n      }\n    } else {\n      multiDragState.activeNode = targetNode;\n      if (selectedClass) {\n        addClass([targetNode.el], selectedClass, true);\n      }\n      multiDragState.selectedNodes.push(targetNode);\n    }\n  } else if (!commandKey && multiDragState.isTouch === false) {\n    if (multiDragState.selectedNodes.map((x) => x.el).includes(targetNode.el)) {\n      multiDragState.selectedNodes = multiDragState.selectedNodes.filter(\n        (el) => el.el !== targetNode.el\n      );\n      if (selectedClass) {\n        removeClass([targetNode.el], selectedClass);\n      }\n    } else {\n      multiDragState.activeNode = {\n        el: data.targetData.node.el,\n        data: data.targetData.node.data\n      };\n      if (selectedClass) {\n        for (const el of multiDragState.selectedNodes) {\n          removeClass([el.el], selectedClass);\n        }\n        addClass([data.targetData.node.el], selectedClass, true);\n      }\n      multiDragState.selectedNodes = [\n        {\n          el: data.targetData.node.el,\n          data: data.targetData.node.data\n        }\n      ];\n    }\n  } else {\n    if (multiDragState.selectedNodes.map((x) => x.el).includes(targetNode.el)) {\n      multiDragState.selectedNodes = multiDragState.selectedNodes.filter(\n        (el) => el.el !== targetNode.el\n      );\n      if (selectedClass) {\n        removeClass([targetNode.el], selectedClass);\n      }\n    } else {\n      multiDragState.activeNode = targetNode;\n      if (selectedClass) {\n        addClass([targetNode.el], selectedClass, true);\n      }\n      multiDragState.selectedNodes.push(targetNode);\n    }\n  }\n}\nfunction keydown(data) {\n  if (!(data.e instanceof KeyboardEvent))\n    return;\n  const keys = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"];\n  if (!keys.includes(data.e.key) || !multiDragState.activeNode)\n    return;\n  const selectionsConfig = data.targetData.parent.data.config.selectionsConfig;\n  data.e.preventDefault();\n  const parentData = data.targetData.parent.data;\n  const nodeData = data.targetData.node.data;\n  const enabledNodes = parentData.enabledNodes;\n  const moveUp = data.e.key === \"ArrowUp\" || data.e.key === \"ArrowLeft\";\n  const moveDown = data.e.key === \"ArrowDown\" || data.e.key === \"ArrowRight\";\n  const invalidKeydown = moveUp && nodeData.index === 0 || moveDown && nodeData.index === enabledNodes.length - 1;\n  if (invalidKeydown)\n    return;\n  const adjacentNode = enabledNodes[nodeData.index + (moveUp ? -1 : 1)];\n  const selectedClass = selectionsConfig.selectedClass;\n  if (!adjacentNode)\n    return;\n  if (data.e.altKey) {\n    if (multiDragState.selectedNodes.length > 1) {\n      for (const el of multiDragState.selectedNodes) {\n        if (selectedClass && multiDragState.activeNode !== el) {\n          removeClass([el.el], selectedClass);\n        }\n      }\n      multiDragState.selectedNodes = multiDragState.selectedNodes.filter(\n        (el) => el !== multiDragState.activeNode\n      );\n    }\n    const parentValues2 = parentData.getValues(data.targetData.parent.el);\n    [\n      parentValues2[nodeData.index],\n      parentValues2[nodeData.index + (moveUp ? -1 : 1)]\n    ] = [\n      parentValues2[nodeData.index + (moveUp ? -1 : 1)],\n      parentValues2[nodeData.index]\n    ];\n    parentData.setValues(parentValues2, data.targetData.parent.el);\n  } else if (data.e.shiftKey && multiDragState.isTouch === false) {\n    if (!multiDragState.selectedNodes.map((x) => x.el).includes(adjacentNode.el)) {\n      multiDragState.selectedNodes.push(adjacentNode);\n      if (selectedClass) {\n        addClass([adjacentNode.el], selectedClass, true);\n      }\n      multiDragState.activeNode = adjacentNode;\n    } else {\n      if (multiDragState.selectedNodes.map((x) => x.el).includes(multiDragState.activeNode.el)) {\n        multiDragState.selectedNodes = multiDragState.selectedNodes.filter(\n          (el) => el !== multiDragState.activeNode\n        );\n        if (selectedClass) {\n          removeClass([multiDragState.activeNode.el], selectedClass);\n        }\n        multiDragState.activeNode = adjacentNode;\n      }\n    }\n  } else {\n    for (const el of multiDragState.selectedNodes) {\n      if (selectedClass && multiDragState.activeNode !== el) {\n        removeClass([el.el], selectedClass);\n      }\n    }\n    removeClass([multiDragState.activeNode.el], selectedClass);\n    multiDragState.selectedNodes = [adjacentNode];\n    addClass([adjacentNode.el], selectedClass, true);\n    multiDragState.activeNode = adjacentNode;\n  }\n  data.targetData.node.el.blur();\n  multiDragState.activeNode = adjacentNode;\n  multiDragState.activeNode.el.focus();\n}\n\n// src/plugins/swap/index.ts\nvar swapState = {\n  draggedOverNodes: Array()\n};\nfunction swap(swapConfig = {}) {\n  return (parent) => {\n    const parentData = parents.get(parent);\n    if (!parentData)\n      return;\n    const swapParentConfig = {\n      ...parentData.config,\n      swapConfig\n    };\n    return {\n      setup() {\n        swapParentConfig.handleDragoverParent = swapConfig.handleDragoverParent || handleDragoverParent;\n        swapParentConfig.handleDragoverNode = swapConfig.handleDragoverNode || handleDragoverNode;\n        swapParentConfig.handleTouchOverNode = swapConfig.handleTouchOverNode || handleTouchOverNode;\n        swapParentConfig.handleTouchOverParent = swapConfig.handleTouchOverParent || handleTouchOverParent;\n        swapParentConfig.handleEnd = swapConfig.handleEnd || handleEnd2;\n        parentData.config = swapParentConfig;\n      }\n    };\n  };\n}\nfunction handleDragoverNode(data) {\n  if (!state)\n    return;\n  dragoverNode(data, state);\n}\nfunction handleDragoverParent(_data) {\n}\nfunction handleTouchOverParent(_data) {\n}\nfunction handleTouchOverNode(data) {\n  if (!state)\n    return;\n  if (data.detail.targetData.parent.el !== state.lastParent.el)\n    return;\n  const dropZoneClass = data.detail.targetData.parent.data.config.touchDropZoneClass;\n  removeClass(\n    swapState.draggedOverNodes.map((node) => node.el),\n    dropZoneClass\n  );\n  const enabledNodes = data.detail.targetData.parent.data.enabledNodes;\n  swapState.draggedOverNodes = enabledNodes.slice(\n    data.detail.targetData.node.data.index,\n    data.detail.targetData.node.data.index + state.draggedNodes.length\n  );\n  addClass(\n    swapState.draggedOverNodes.map((node) => node.el),\n    dropZoneClass,\n    true\n  );\n  state.lastTargetValue = data.detail.targetData.node.data.value;\n  state.lastParent = data.detail.targetData.parent;\n}\nfunction dragoverNode(data, state2) {\n  data.e.preventDefault();\n  data.e.stopPropagation();\n  if (data.targetData.parent.el !== state2.lastParent.el)\n    return;\n  const dropZoneClass = data.targetData.parent.data.config.dropZoneClass;\n  removeClass(\n    swapState.draggedOverNodes.map((node) => node.el),\n    dropZoneClass\n  );\n  const enabledNodes = data.targetData.parent.data.enabledNodes;\n  if (!enabledNodes)\n    return;\n  swapState.draggedOverNodes = enabledNodes.slice(\n    data.targetData.node.data.index,\n    data.targetData.node.data.index + state2.draggedNodes.length\n  );\n  addClass(\n    swapState.draggedOverNodes.map((node) => node.el),\n    dropZoneClass,\n    true\n  );\n  state2.lastTargetValue = data.targetData.node.data.value;\n  state2.lastParent = data.targetData.parent;\n}\nfunction handleEnd2(data) {\n  if (!state)\n    return;\n  if (!state.transferred) {\n    const draggedParentValues = parentValues(\n      state.initialParent.el,\n      state.initialParent.data\n    );\n    let targetParentValues = parentValues(\n      state.lastParent.el,\n      state.lastParent.data\n    );\n    const draggedValues = state.draggedNodes.map((node) => node.data.value);\n    const draggedOverNodeValues = swapState.draggedOverNodes.map(\n      (node) => node.data.value\n    );\n    const draggedIndex = state.draggedNodes[0].data.index;\n    const draggedOverIndex = swapState.draggedOverNodes[0].data.index;\n    targetParentValues.splice(\n      draggedOverIndex,\n      draggedValues.length,\n      ...draggedValues\n    );\n    if (state.initialParent.el === state.lastParent.el) {\n      targetParentValues.splice(\n        draggedIndex,\n        draggedValues.length,\n        ...draggedOverNodeValues\n      );\n      setParentValues(state.initialParent.el, state.initialParent.data, [\n        ...targetParentValues\n      ]);\n    } else {\n      draggedParentValues.splice(\n        draggedIndex,\n        draggedValues.length,\n        ...draggedOverNodeValues\n      );\n      setParentValues(state.lastParent.el, state.lastParent.data, [\n        ...targetParentValues\n      ]);\n      setParentValues(state.initialParent.el, state.initialParent.data, [\n        ...draggedParentValues\n      ]);\n    }\n  }\n  const dropZoneClass = \"touchedNode\" in state ? data.targetData.parent.data.config.touchDropZoneClass : data.targetData.parent.data.config.dropZoneClass;\n  removeClass(\n    swapState.draggedOverNodes.map((node) => node.el),\n    dropZoneClass\n  );\n  handleEnd(data);\n}\n\n// src/plugins/place/index.ts\nvar placeState = {\n  draggedOverNodes: Array()\n};\nfunction place(placeConfig = {}) {\n  return (parent) => {\n    const parentData = parents.get(parent);\n    if (!parentData)\n      return;\n    const placeParentConfig = {\n      ...parentData.config,\n      placeConfig\n    };\n    return {\n      setup() {\n        placeParentConfig.handleDragoverNode = placeConfig.handleDragoverNode || handleDragoverNode2;\n        placeParentConfig.handleTouchOverNode = placeConfig.handleTouchOverNode || handleTouchOverNode2;\n        placeParentConfig.handleTouchOverParent = placeConfig.handleTouchOverParent || handleTouchOverParent2;\n        placeParentConfig.handleEnd = placeConfig.handleEnd || handleEnd3;\n        parentData.config = placeParentConfig;\n      }\n    };\n  };\n}\nfunction handleDragoverNode2(data) {\n  if (!state)\n    return;\n  dragoverNode2(data, state);\n}\nfunction handleTouchOverParent2(_data) {\n}\nfunction handleTouchOverNode2(data) {\n  if (!state)\n    return;\n  if (data.detail.targetData.parent.el !== state.lastParent.el)\n    return;\n  const dropZoneClass = data.detail.targetData.parent.data.config.touchDropZoneClass;\n  removeClass(\n    placeState.draggedOverNodes.map((node) => node.el),\n    dropZoneClass\n  );\n  const enabledNodes = data.detail.targetData.parent.data.enabledNodes;\n  placeState.draggedOverNodes = enabledNodes.slice(\n    data.detail.targetData.node.data.index,\n    data.detail.targetData.node.data.index + state.draggedNodes.length\n  );\n  addClass(\n    placeState.draggedOverNodes.map((node) => node.el),\n    dropZoneClass,\n    true\n  );\n  state.lastTargetValue = data.detail.targetData.node.data.value;\n  state.lastParent = data.detail.targetData.parent;\n}\nfunction dragoverNode2(data, state2) {\n  data.e.preventDefault();\n  data.e.stopPropagation();\n  if (data.targetData.parent.el !== state2.lastParent.el)\n    return;\n  const dropZoneClass = data.targetData.parent.data.config.dropZoneClass;\n  removeClass(\n    placeState.draggedOverNodes.map((node) => node.el),\n    dropZoneClass\n  );\n  const enabledNodes = data.targetData.parent.data.enabledNodes;\n  if (!enabledNodes)\n    return;\n  placeState.draggedOverNodes = enabledNodes.slice(\n    data.targetData.node.data.index,\n    data.targetData.node.data.index + state2.draggedNodes.length\n  );\n  addClass(\n    placeState.draggedOverNodes.map((node) => node.el),\n    dropZoneClass,\n    true\n  );\n  state2.lastTargetValue = data.targetData.node.data.value;\n  state2.lastParent = data.targetData.parent;\n}\nfunction handleEnd3(data) {\n  if (!state)\n    return;\n  if (state.transferred || state.lastParent.el !== state.initialParent.el)\n    return;\n  const draggedParentValues = parentValues(\n    state.initialParent.el,\n    state.initialParent.data\n  );\n  const draggedValues = state.draggedNodes.map((node) => node.data.value);\n  const newParentValues = [\n    ...draggedParentValues.filter((x) => !draggedValues.includes(x))\n  ];\n  const index = placeState.draggedOverNodes[0].data.index;\n  newParentValues.splice(index, 0, ...draggedValues);\n  setParentValues(data.targetData.parent.el, data.targetData.parent.data, [\n    ...newParentValues\n  ]);\n  const dropZoneClass = \"touchedNode\" in state ? data.targetData.parent.data.config.touchDropZoneClass : data.targetData.parent.data.config.dropZoneClass;\n  removeClass(\n    placeState.draggedOverNodes.map((node) => node.el),\n    dropZoneClass\n  );\n  handleEnd(data);\n}\n\n// src/index.ts\nvar scrollConfig = {\n  up: [0, -1],\n  down: [0, 1],\n  left: [-1, 0],\n  right: [1, 0]\n};\nvar nodes = /* @__PURE__ */ new WeakMap();\nvar parents = /* @__PURE__ */ new WeakMap();\nvar state = void 0;\nfunction resetState() {\n  state = void 0;\n}\nfunction setDragState(dragStateProps2) {\n  state = {\n    ascendingDirection: false,\n    incomingDirection: void 0,\n    enterCount: 0,\n    targetIndex: 0,\n    affectedNodes: [],\n    lastValue: void 0,\n    activeNode: void 0,\n    lastTargetValue: void 0,\n    remapJustFinished: false,\n    preventEnter: false,\n    clonedDraggedEls: [],\n    originalZIndex: void 0,\n    transferred: false,\n    ...dragStateProps2\n  };\n  return state;\n}\nfunction setTouchState(dragState, touchStateProps) {\n  state = {\n    ...dragState,\n    ...touchStateProps\n  };\n  return state;\n}\nfunction dragStateProps(data) {\n  const { x, y } = eventCoordinates(data.e);\n  return {\n    coordinates: {\n      x,\n      y\n    },\n    draggedNode: {\n      el: data.targetData.node.el,\n      data: data.targetData.node.data\n    },\n    draggedNodes: [\n      {\n        el: data.targetData.node.el,\n        data: data.targetData.node.data\n      }\n    ],\n    initialIndex: data.targetData.node.data.index,\n    initialParent: {\n      el: data.targetData.parent.el,\n      data: data.targetData.parent.data\n    },\n    lastParent: {\n      el: data.targetData.parent.el,\n      data: data.targetData.parent.data\n    },\n    scrollParent: getScrollParent(data.targetData.node.el)\n  };\n}\nfunction performSort(state2, data) {\n  const draggedValues = dragValues(state2);\n  const targetParentValues = parentValues(\n    data.targetData.parent.el,\n    data.targetData.parent.data\n  );\n  const newParentValues = [\n    ...targetParentValues.filter((x) => !draggedValues.includes(x))\n  ];\n  newParentValues.splice(data.targetData.node.data.index, 0, ...draggedValues);\n  state2.lastTargetValue = data.targetData.node.data.value;\n  setParentValues(data.targetData.parent.el, data.targetData.parent.data, [\n    ...newParentValues\n  ]);\n}\nfunction parentValues(parent, parentData) {\n  return [...parentData.getValues(parent)];\n}\nfunction setParentValues(parent, parentData, values) {\n  parentData.setValues(values, parent);\n}\nfunction dragValues(state2) {\n  return [...state2.draggedNodes.map((x) => x.data.value)];\n}\nfunction updateConfig(parent, config) {\n  const parentData = parents.get(parent);\n  if (!parentData)\n    return;\n  parents.set(parent, {\n    ...parentData,\n    config: { ...parentData.config, ...config }\n  });\n  dragAndDrop({\n    parent,\n    getValues: parentData.getValues,\n    setValues: parentData.setValues,\n    config\n  });\n}\nfunction dragAndDrop({\n  parent,\n  getValues,\n  setValues,\n  config = {}\n}) {\n  if (!isBrowser)\n    return;\n  document.addEventListener(\"dragover\", (e) => {\n    e.preventDefault();\n    if (nodes.has(e.target) || parents.has(e.target))\n      return;\n    if (state) {\n      state.remapJustFinished = false;\n      state.lastTargetValue = void 0;\n      const { x, y } = eventCoordinates(e);\n      state.coordinates.y = y;\n      state.coordinates.x = x;\n      handleScroll();\n    }\n  });\n  tearDown(parent);\n  const parentData = {\n    getValues,\n    setValues,\n    config: {\n      handleDragstart,\n      handleDragoverNode: handleDragoverNode3,\n      handleDragoverParent: handleDragoverParent2,\n      handleEnd,\n      handleTouchstart,\n      handleTouchmove,\n      handleTouchOverNode: handleTouchOverNode3,\n      handleTouchOverParent: handleTouchOverParent3,\n      handleDragenterNode,\n      handleDragleaveNode,\n      performSort,\n      performTransfer,\n      root: document,\n      setupNode,\n      setupNodeRemap,\n      reapplyDragClasses,\n      tearDownNode,\n      tearDownNodeRemap,\n      remapFinished,\n      scrollBehavior: {\n        x: 0.8,\n        y: 0.8\n      },\n      threshold: {\n        horizontal: 0,\n        vertical: 0\n      },\n      ...config\n    },\n    enabledNodes: [],\n    abortControllers: {}\n  };\n  const nodesObserver = new MutationObserver(nodesMutated);\n  nodesObserver.observe(parent, { childList: true });\n  parents.set(parent, parentData);\n  config.plugins?.forEach((plugin) => {\n    plugin(parent)?.tearDown?.();\n  });\n  config.plugins?.forEach((plugin) => {\n    plugin(parent)?.tearDown?.();\n  });\n  config.plugins?.forEach((plugin) => {\n    plugin(parent)?.setup?.();\n  });\n  setup(parent, parentData);\n  remapNodes(parent, true);\n}\nfunction tearDown(parent) {\n  const parentData = parents.get(parent);\n  if (!parentData)\n    return;\n  if (parentData.abortControllers.mainParent) {\n    parentData.abortControllers.mainParent.abort();\n  }\n}\nfunction setup(parent, parentData) {\n  parentData.abortControllers.mainParent = addEvents(parent, {\n    dragover: parentEventData(\n      throttle(parentData.config.handleDragoverParent, 10)\n    ),\n    touchOverParent: parentData.config.handleTouchOverParent\n  });\n}\nfunction nodesMutated(mutationList) {\n  const parentEl = mutationList[0].target;\n  if (!(parentEl instanceof HTMLElement))\n    return;\n  remapNodes(parentEl);\n}\nfunction remapNodes(parent, force) {\n  const parentData = parents.get(parent);\n  if (!parentData)\n    return;\n  const enabledNodes = [];\n  const config = parentData.config;\n  for (let x = 0; x < parent.children.length; x++) {\n    const node = parent.children[x];\n    if (!isNode(node))\n      continue;\n    const nodeData = nodes.get(node);\n    if (force || !nodeData) {\n      config.tearDownNode({ node, parent, nodeData, parentData });\n    }\n    if (config.disabled)\n      continue;\n    if (!config.draggable || config.draggable && config.draggable(node)) {\n      enabledNodes.push(node);\n    }\n  }\n  if (enabledNodes.length !== parentData.getValues(parent).length && !config.disabled) {\n    console.warn(\n      \"The number of enabled nodes does not match the number of values.\"\n    );\n    return;\n  }\n  const values = parentData.getValues(parent);\n  const enabledNodeRecords = [];\n  for (let x = 0; x < enabledNodes.length; x++) {\n    const node = enabledNodes[x];\n    const prevNodeData = nodes.get(node);\n    const nodeData = Object.assign(\n      prevNodeData ?? {\n        privateClasses: [],\n        abortControllers: {}\n      },\n      {\n        value: values[x],\n        index: x\n      }\n    );\n    if (state && nodeData.value === state.draggedNode.data.value) {\n      state.draggedNode.data = nodeData;\n      state.draggedNode.el = node;\n    }\n    if (state && state.draggedNodes.map((x2) => x2.data.value).includes(nodeData.value)) {\n      const draggedNode = state.draggedNodes.find(\n        (x2) => x2.data.value === nodeData.value\n      );\n      if (draggedNode)\n        draggedNode.el = node;\n    }\n    enabledNodeRecords.push({\n      el: node,\n      data: nodeData\n    });\n    const setupNodeData = {\n      node,\n      parent,\n      parentData,\n      nodeData\n    };\n    if (force || !prevNodeData)\n      config.setupNode(setupNodeData);\n    setupNodeRemap(setupNodeData);\n  }\n  parents.set(parent, { ...parentData, enabledNodes: enabledNodeRecords });\n  config.remapFinished(parentData);\n}\nfunction remapFinished() {\n  if (state) {\n    state.remapJustFinished = true;\n    state.affectedNodes = [];\n  }\n}\nfunction handleDragstart(data) {\n  if (!(data.e instanceof DragEvent))\n    return;\n  dragstart({\n    e: data.e,\n    targetData: data.targetData\n  });\n}\nfunction dragstartClasses(el, draggingClass, dropZoneClass) {\n  addClass([el], draggingClass);\n  setTimeout(() => {\n    removeClass([el], draggingClass);\n    addClass([el], dropZoneClass);\n  });\n}\nfunction initDrag(eventData) {\n  const dragState = setDragState(dragStateProps(eventData));\n  eventData.e.stopPropagation();\n  if (eventData.e.dataTransfer) {\n    eventData.e.dataTransfer.dropEffect = \"move\";\n    eventData.e.dataTransfer.effectAllowed = \"move\";\n    eventData.e.dataTransfer.setDragImage(\n      eventData.targetData.node.el,\n      eventData.e.offsetX,\n      eventData.e.offsetY\n    );\n  }\n  return dragState;\n}\nfunction validateDragHandle(data) {\n  if (!(data.e instanceof DragEvent) && !(data.e instanceof TouchEvent))\n    return false;\n  const config = data.targetData.parent.data.config;\n  if (!config.dragHandle)\n    return true;\n  const dragHandles = data.targetData.node.el.querySelectorAll(\n    config.dragHandle\n  );\n  if (!dragHandles)\n    return false;\n  const coordinates = eventCoordinates(data.e);\n  const elFromPoint = config.root.elementFromPoint(\n    coordinates.x,\n    coordinates.y\n  );\n  if (!elFromPoint)\n    return false;\n  for (const handle of Array.from(dragHandles)) {\n    if (elFromPoint === handle || handle.contains(elFromPoint))\n      return true;\n  }\n  return false;\n}\nfunction touchstart(data) {\n  if (!validateDragHandle(data))\n    return;\n  const touchState = initTouch(data);\n  handleTouchedNode(data, touchState);\n  handleLongTouch(data, touchState);\n}\nfunction dragstart(data) {\n  if (!validateDragHandle(data)) {\n    data.e.preventDefault();\n    return;\n  }\n  const config = data.targetData.parent.data.config;\n  const dragState = initDrag(data);\n  const originalZIndex = data.targetData.node.el.style.zIndex;\n  dragState.originalZIndex = originalZIndex;\n  data.targetData.node.el.style.zIndex = \"9999\";\n  dragstartClasses(\n    dragState.draggedNode.el,\n    config.draggingClass,\n    config.dropZoneClass\n  );\n}\nfunction handleTouchOverNode3(e) {\n  if (!state)\n    return;\n  if (e.detail.targetData.parent.el === state.lastParent.el)\n    sort(e.detail, state);\n  else\n    transfer(e.detail, state);\n}\nfunction setupNode(data) {\n  const config = data.parentData.config;\n  data.node.draggable = true;\n  data.nodeData.abortControllers.mainNode = addEvents(data.node, {\n    dragstart: nodeEventData(config.handleDragstart),\n    dragover: nodeEventData(config.handleDragoverNode),\n    dragenter: nodeEventData(config.handleDragenterNode),\n    dragleave: nodeEventData(config.handleDragleaveNode),\n    dragend: nodeEventData(config.handleEnd),\n    touchstart: nodeEventData(config.handleTouchstart),\n    touchmove: nodeEventData(config.handleTouchmove),\n    touchend: nodeEventData(config.handleEnd),\n    touchOverNode: config.handleTouchOverNode\n  });\n  config.reapplyDragClasses(data.node, data.parentData);\n  data.parentData.config.plugins?.forEach((plugin) => {\n    plugin(data.parent)?.setupNode?.(data);\n  });\n}\nfunction setupNodeRemap(data) {\n  nodes.set(data.node, data.nodeData);\n  data.parentData.config.plugins?.forEach((plugin) => {\n    plugin(data.parent)?.setupNodeRemap?.(data);\n  });\n}\nfunction reapplyDragClasses(node, parentData) {\n  if (!state)\n    return;\n  const dropZoneClass = \"touchedNode\" in state ? parentData.config.touchDropZoneClass : parentData.config.dropZoneClass;\n  if (state.draggedNode.el !== node)\n    return;\n  addClass([node], dropZoneClass, true);\n}\nfunction tearDownNodeRemap(data) {\n  data.parentData.config.plugins?.forEach((plugin) => {\n    plugin(data.parent)?.tearDownNodeRemap?.(data);\n  });\n}\nfunction tearDownNode(data) {\n  data.parentData.config.plugins?.forEach((plugin) => {\n    plugin(data.parent)?.tearDownNode?.(data);\n  });\n  data.node.draggable = false;\n  if (data.nodeData?.abortControllers?.mainNode) {\n    data.nodeData?.abortControllers?.mainNode.abort();\n  }\n}\nfunction handleEnd(eventData) {\n  if (!state)\n    return;\n  end(eventData, state);\n  resetState();\n}\nfunction end(_eventData, state2) {\n  document.removeEventListener(\"contextmenu\", preventDefault);\n  if (\"longTouchTimeout\" in state2 && state2.longTouchTimeout)\n    clearTimeout(state2.longTouchTimeout);\n  const config = parents.get(state2.initialParent.el)?.config;\n  const isTouch = \"touchedNode\" in state2;\n  const dropZoneClass = isTouch ? config?.touchDropZoneClass : config?.dropZoneClass;\n  if (state2.originalZIndex !== void 0)\n    state2.draggedNode.el.style.zIndex = state2.originalZIndex;\n  addClass(\n    state2.draggedNodes.map((x) => x.el),\n    dropZoneClass,\n    true\n  );\n  removeClass(\n    state2.draggedNodes.map((x) => x.el),\n    dropZoneClass\n  );\n  if (config?.longTouchClass) {\n    removeClass(\n      state2.draggedNodes.map((x) => x.el),\n      state2.initialParent.data?.config?.longTouchClass\n    );\n  }\n  if (\"touchedNode\" in state2)\n    state2.touchedNode?.remove();\n}\nfunction handleTouchstart(eventData) {\n  if (!(eventData.e instanceof TouchEvent))\n    return;\n  touchstart({\n    e: eventData.e,\n    targetData: eventData.targetData\n  });\n}\nfunction initTouch(data) {\n  data.e.stopPropagation();\n  const clonedNode = data.targetData.node.el.cloneNode(true);\n  const rect = data.targetData.node.el.getBoundingClientRect();\n  const touchState = setTouchState(setDragState(dragStateProps(data)), {\n    coordinates: {\n      x: data.e.touches[0].clientX,\n      y: data.e.touches[0].clientY\n    },\n    scrollParent: getScrollParent(data.targetData.node.el),\n    touchStartLeft: data.e.touches[0].clientX - rect.left,\n    touchStartTop: data.e.touches[0].clientY - rect.top,\n    touchedNode: clonedNode,\n    touchMoving: false\n  });\n  return touchState;\n}\nfunction preventDefault(e) {\n  e.preventDefault();\n}\nfunction handleTouchedNode(data, touchState) {\n  touchState.touchedNodeDisplay = touchState.touchedNode.style.display;\n  const rect = data.targetData.node.el.getBoundingClientRect();\n  touchState.touchedNode.style.cssText = `\n            width: ${rect.width}px;\n            position: fixed;\n            pointer-events: none;\n            top: -9999px;\n            z-index: 999999;\n            display: none;\n          `;\n  document.body.append(touchState.touchedNode);\n  copyNodeStyle(data.targetData.node.el, touchState.touchedNode);\n  touchState.touchedNode.style.display = \"none\";\n  document.addEventListener(\"contextmenu\", preventDefault);\n}\nfunction handleLongTouch(data, touchState) {\n  const config = data.targetData.parent.data.config;\n  if (!config.longTouch)\n    return;\n  touchState.longTouchTimeout = setTimeout(() => {\n    if (!touchState)\n      return;\n    touchState.longTouch = true;\n    if (config.longTouchClass && data.e.cancelable)\n      addClass(\n        touchState.draggedNodes.map((x) => x.el),\n        config.longTouchClass\n      );\n    data.e.preventDefault();\n  }, config.longTouchTimeout || 200);\n}\nfunction handleTouchmove(eventData) {\n  if (!state || !(\"touchedNode\" in state))\n    return;\n  touchmove(eventData, state);\n}\nfunction touchmoveClasses(touchState, config) {\n  if (config.longTouchClass)\n    removeClass(\n      touchState.draggedNodes.map((x) => x.el),\n      config?.longTouchClass\n    );\n  if (config.touchDraggingClass)\n    addClass([touchState.touchedNode], config.touchDraggingClass);\n  if (config.touchDropZoneClass)\n    addClass(\n      touchState.draggedNodes.map((x) => x.el),\n      config.touchDropZoneClass\n    );\n}\nfunction getScrollData(state2) {\n  if (!state2 || !state2.scrollParent)\n    return;\n  if (state2.scrollParent === document.documentElement && !(\"touchedNode\" in state2)) {\n    return;\n  }\n  const { x, y, width, height } = state2.scrollParent.getBoundingClientRect();\n  const {\n    x: xThresh,\n    y: yThresh,\n    scrollOutside\n  } = state2.lastParent.data.config.scrollBehavior;\n  return {\n    state: state2,\n    xThresh,\n    yThresh,\n    scrollOutside,\n    scrollParent: state2.scrollParent,\n    x,\n    y,\n    width,\n    height\n  };\n}\nfunction shouldScroll(direction) {\n  const data = getScrollData(state);\n  if (!data)\n    return;\n  switch (direction) {\n    case \"down\":\n      return shouldScrollDown(data.state, data);\n    case \"up\":\n      return shouldScrollUp(data.state, data);\n    case \"right\":\n      return shouldScrollRight(data.state, data);\n    case \"left\":\n      return shouldScrollLeft(data.state, data);\n  }\n}\nfunction shouldScrollRight(state2, data) {\n  const diff = data.scrollParent.clientWidth + data.x - state2.coordinates.x;\n  if (!data.scrollOutside && diff < 0)\n    return;\n  if (diff < (1 - data.xThresh) * data.scrollParent.clientWidth && !(data.scrollParent.scrollLeft + data.scrollParent.clientWidth >= data.scrollParent.scrollWidth))\n    return state2;\n}\nfunction shouldScrollLeft(state2, data) {\n  const diff = data.scrollParent.clientWidth + data.x - state2.coordinates.x;\n  if (!data.scrollOutside && diff > data.scrollParent.clientWidth)\n    return;\n  if (diff > data.xThresh * data.scrollParent.clientWidth && data.scrollParent.scrollLeft !== 0)\n    return state2;\n}\nfunction shouldScrollUp(state2, data) {\n  const diff = data.scrollParent.clientHeight + data.y - state2.coordinates.y;\n  if (!data.scrollOutside && diff > data.scrollParent.clientHeight)\n    return;\n  if (diff > data.yThresh * data.scrollParent.clientHeight && data.scrollParent.scrollTop !== 0)\n    return state2;\n}\nfunction shouldScrollDown(state2, data) {\n  const diff = data.scrollParent.clientHeight + data.y - state2.coordinates.y;\n  if (!data.scrollOutside && diff < 0)\n    return;\n  if (diff < (1 - data.yThresh) * data.scrollParent.clientHeight && !(data.scrollParent.scrollTop + data.scrollParent.clientHeight >= data.scrollParent.scrollHeight))\n    return state2;\n}\nfunction moveTouchedNode(data, touchState) {\n  touchState.touchMoving = true;\n  touchState.touchedNode.style.display = touchState.touchedNodeDisplay || \"\";\n  const { x, y } = eventCoordinates(data.e);\n  touchState.coordinates.y = y;\n  touchState.coordinates.x = x;\n  const touchStartLeft = touchState.touchStartLeft ?? 0;\n  const touchStartTop = touchState.touchStartTop ?? 0;\n  touchState.touchedNode.style.left = `${x - touchStartLeft}px`;\n  touchState.touchedNode.style.top = `${y - touchStartTop}px`;\n  touchmoveClasses(touchState, data.targetData.parent.data.config);\n}\nfunction touchmove(data, touchState) {\n  const config = data.targetData.parent.data.config;\n  if (config.longTouch && !touchState.longTouch) {\n    clearTimeout(touchState.longTouchTimeout);\n    return;\n  }\n  if (data.e.cancelable)\n    data.e.preventDefault();\n  moveTouchedNode(data, touchState);\n  handleScroll();\n  const elFromPoint = getElFromPoint(data);\n  if (!elFromPoint)\n    return;\n  const touchMoveEventData = {\n    e: data.e,\n    targetData: elFromPoint\n  };\n  if (\"node\" in elFromPoint) {\n    elFromPoint.node.el.dispatchEvent(\n      new CustomEvent(\"touchOverNode\", {\n        detail: touchMoveEventData\n      })\n    );\n  } else {\n    elFromPoint.parent.el.dispatchEvent(\n      new CustomEvent(\"touchOverParent\", {\n        detail: touchMoveEventData\n      })\n    );\n  }\n}\nfunction handleScroll() {\n  for (const direction of Object.keys(scrollConfig)) {\n    const [x, y] = scrollConfig[direction];\n    performScroll(direction, x, y);\n  }\n}\nfunction performScroll(direction, x, y) {\n  const state2 = shouldScroll(direction);\n  if (!state2)\n    return;\n  state2.scrollParent.scrollBy(x, y);\n  setTimeout(\n    () => {\n      performScroll(direction, x, y);\n    },\n    \"touchedNode\" in state2 ? 10 : 100\n  );\n}\nfunction handleDragoverNode3(data) {\n  if (!state)\n    return;\n  const { x, y } = eventCoordinates(data.e);\n  state.coordinates.y = y;\n  state.coordinates.x = x;\n  handleScroll();\n  dragoverNode3(data, state);\n}\nfunction handleDragoverParent2(data) {\n  if (!state)\n    return;\n  const { x, y } = eventCoordinates(data.e);\n  state.coordinates.y = y;\n  state.coordinates.x = x;\n  handleScroll();\n  transfer(data, state);\n}\nfunction handleTouchOverParent3(e) {\n  if (!state)\n    return;\n  transfer(e.detail, state);\n}\nfunction validateTransfer(data, state2) {\n  if (data.targetData.parent.el === state2.lastParent.el)\n    return false;\n  const targetConfig = data.targetData.parent.data.config;\n  if (targetConfig.dropZone === false)\n    return false;\n  const initialParentConfig = state2.initialParent.data.config;\n  if (targetConfig.accepts) {\n    return targetConfig.accepts(\n      data.targetData.parent,\n      state2.initialParent,\n      state2.lastParent,\n      state2\n    );\n  } else if (!targetConfig.group || targetConfig.group !== initialParentConfig.group) {\n    return false;\n  }\n  return true;\n}\nfunction handleDragenterNode(data, _state) {\n  data.e.preventDefault();\n}\nfunction handleDragleaveNode(data, _state) {\n  data.e.preventDefault();\n}\nfunction dragoverNode3(eventData, dragState) {\n  eventData.e.preventDefault();\n  eventData.e.stopPropagation();\n  eventData.targetData.parent.el === dragState.lastParent?.el ? sort(eventData, dragState) : transfer(eventData, dragState);\n}\nfunction validateSort(data, state2, x, y) {\n  if (state2.affectedNodes.map((x2) => x2.data.value).includes(data.targetData.node.data.value)) {\n    return false;\n  }\n  if (state2.remapJustFinished) {\n    state2.remapJustFinished = false;\n    if (data.targetData.node.data.value === state2.lastTargetValue || state2.draggedNodes.map((x2) => x2.el).includes(data.targetData.node.el)) {\n      state2.lastTargetValue = data.targetData.node.data.value;\n    }\n    return false;\n  }\n  if (state2.draggedNodes.map((x2) => x2.el).includes(data.targetData.node.el)) {\n    state2.lastTargetValue = void 0;\n    return false;\n  }\n  if (data.targetData.node.data.value === state2.lastTargetValue)\n    return false;\n  if (state2.preventEnter || data.targetData.parent.el !== state2.lastParent?.el || data.targetData.parent.data.config.sortable === false)\n    return false;\n  const targetRect = data.targetData.node.el.getBoundingClientRect();\n  const dragRect = state2.draggedNode.el.getBoundingClientRect();\n  const yDiff = targetRect.y - dragRect.y;\n  const xDiff = targetRect.x - dragRect.x;\n  let incomingDirection;\n  if (Math.abs(yDiff) > Math.abs(xDiff)) {\n    incomingDirection = yDiff > 0 ? \"above\" : \"below\";\n  } else {\n    incomingDirection = xDiff > 0 ? \"left\" : \"right\";\n  }\n  const threshold = state2.lastParent.data.config.threshold;\n  switch (incomingDirection) {\n    case \"left\":\n      if (x > targetRect.x + targetRect.width * threshold.horizontal) {\n        state2.incomingDirection = \"left\";\n        return true;\n      }\n      break;\n    case \"right\":\n      if (x < targetRect.x + targetRect.width * (1 - threshold.horizontal)) {\n        state2.incomingDirection = \"right\";\n        return true;\n      }\n      break;\n    case \"above\":\n      if (y > targetRect.y + targetRect.height * threshold.vertical) {\n        state2.incomingDirection = \"above\";\n        return true;\n      }\n      break;\n    case \"below\":\n      if (y < targetRect.y + targetRect.height * (1 - threshold.vertical)) {\n        state2.incomingDirection = \"below\";\n        return true;\n      }\n      break;\n    default:\n      break;\n  }\n  return false;\n}\nfunction sort(data, state2) {\n  const { x, y } = eventCoordinates(data.e);\n  if (!validateSort(data, state2, x, y))\n    return;\n  const range = state2.draggedNode.data.index > data.targetData.node.data.index ? [data.targetData.node.data.index, state2.draggedNode.data.index] : [state2.draggedNode.data.index, data.targetData.node.data.index];\n  state2.targetIndex = data.targetData.node.data.index;\n  state2.affectedNodes = data.targetData.parent.data.enabledNodes.filter(\n    (node) => {\n      return range[0] <= node.data.index && node.data.index <= range[1] && node.el !== state2.draggedNode.el;\n    }\n  );\n  data.targetData.parent.data.config.performSort(state2, data);\n}\nfunction nodeEventData(callback) {\n  function nodeTargetData(node) {\n    const nodeData = nodes.get(node);\n    const parent = node.parentNode || state?.lastParent?.el;\n    if (!nodeData)\n      return;\n    const parentData = parents.get(parent);\n    if (!parentData)\n      return;\n    return {\n      node: {\n        el: node,\n        data: nodeData\n      },\n      parent: {\n        el: parent,\n        data: parentData\n      }\n    };\n  }\n  return (e) => {\n    const targetData = nodeTargetData(e.currentTarget);\n    if (!targetData)\n      return;\n    return callback({\n      e,\n      targetData\n    });\n  };\n}\nfunction performTransfer(state2, data) {\n  const draggedValues = dragValues(state2);\n  const lastParentValues = parentValues(\n    state2.lastParent.el,\n    state2.lastParent.data\n  ).filter((x) => !draggedValues.includes(x));\n  const targetParentValues = parentValues(\n    data.targetData.parent.el,\n    data.targetData.parent.data\n  );\n  const reset = state2.initialParent.el === data.targetData.parent.el && data.targetData.parent.data.config.sortable === false;\n  let targetIndex;\n  if (\"node\" in data.targetData) {\n    if (reset) {\n      targetIndex = state2.initialIndex;\n    } else if (data.targetData.parent.data.config.sortable === false) {\n      targetIndex = data.targetData.parent.data.enabledNodes.length;\n    } else {\n      targetIndex = data.targetData.node.data.index;\n    }\n    targetParentValues.splice(targetIndex, 0, ...draggedValues);\n  } else {\n    targetIndex = reset ? state2.initialIndex : data.targetData.parent.data.enabledNodes.length;\n    targetParentValues.splice(targetIndex, 0, ...draggedValues);\n  }\n  setParentValues(state2.lastParent.el, state2.lastParent.data, lastParentValues);\n  setParentValues(\n    data.targetData.parent.el,\n    data.targetData.parent.data,\n    targetParentValues\n  );\n}\nfunction transfer(data, state2) {\n  if (!validateTransfer(data, state2))\n    return;\n  data.targetData.parent.data.config.performTransfer(state2, data);\n  state2.lastParent = data.targetData.parent;\n  state2.transferred = true;\n}\nfunction parentEventData(callback) {\n  function parentTargetData(parent) {\n    const parentData = parents.get(parent);\n    if (!parentData)\n      return;\n    return {\n      parent: {\n        el: parent,\n        data: parentData\n      }\n    };\n  }\n  return (e) => {\n    const targetData = parentTargetData(e.currentTarget);\n    if (!targetData)\n      return;\n    return callback({\n      e,\n      targetData\n    });\n  };\n}\nexport {\n  addClass,\n  addEvents,\n  animations,\n  copyNodeStyle,\n  dragAndDrop,\n  dragStateProps,\n  dragValues,\n  dragstart,\n  dragstartClasses,\n  end,\n  eventCoordinates,\n  events,\n  getElFromPoint,\n  getScrollParent,\n  handleDragoverNode3 as handleDragoverNode,\n  handleDragoverParent2 as handleDragoverParent,\n  handleDragstart,\n  handleEnd,\n  handleLongTouch,\n  handleSelections,\n  handleTouchOverNode3 as handleTouchOverNode,\n  handleTouchOverParent3 as handleTouchOverParent,\n  handleTouchedNode,\n  handleTouchmove,\n  handleTouchstart,\n  initDrag,\n  initTouch,\n  isBrowser,\n  isNode,\n  multiDrag,\n  multiDragState,\n  multiDragstart,\n  multiHandleDragstart,\n  multiHandleEnd,\n  multiHandleTouchstart,\n  multiReapplyDragClasses,\n  multiTouchstart,\n  nodeEventData,\n  nodes,\n  parentEventData,\n  parentValues,\n  parents,\n  performSort,\n  performTransfer,\n  place,\n  remapFinished,\n  remapNodes,\n  removeClass,\n  resetState,\n  selections,\n  selectionsEnd,\n  setDragState,\n  setParentValues,\n  setTouchState,\n  setupNode,\n  setupNodeRemap,\n  sort,\n  stackNodes,\n  state,\n  swap,\n  tearDown,\n  tearDownNode,\n  tearDownNodeRemap,\n  throttle,\n  transfer,\n  updateConfig,\n  validateSort,\n  validateTransfer\n};\n//# sourceMappingURL=index.mjs.map","// src/vue/index.ts\nimport {\n  dragAndDrop as initParent,\n  isBrowser,\n  tearDown\n} from \"../index.mjs\";\n\n// src/vue/utils.ts\nimport { watch } from \"vue\";\nfunction getEl(parent) {\n  if (parent instanceof HTMLElement)\n    return parent;\n  else if (parent.value instanceof HTMLElement)\n    return parent.value;\n  else if (\"$el\" in parent && parent.$el instanceof HTMLElement)\n    return parent.$el;\n}\nfunction handleVueElements(elements, cb) {\n  if (!Array.isArray(elements))\n    elements = [elements];\n  for (const element of elements) {\n    const validEl = getEl(element);\n    if (validEl)\n      return cb(validEl);\n    const stop = watch(element, (newEl) => {\n      if (!newEl)\n        return;\n      const validEl2 = getEl(newEl);\n      !validEl2 ? console.warn(\"Invalid parent element\", newEl) : cb(validEl2);\n      stop();\n    });\n  }\n}\n\n// src/vue/index.ts\nimport { onUnmounted, ref } from \"vue\";\nvar parentValues = /* @__PURE__ */ new WeakMap();\nfunction getValues(parent) {\n  const values = parentValues.get(parent);\n  if (!values) {\n    console.warn(\"No values found for parent element\");\n    return [];\n  }\n  return values.value;\n}\nfunction setValues(newValues, parent) {\n  const currentValues = parentValues.get(parent);\n  if (currentValues)\n    currentValues.value = newValues;\n}\nfunction dragAndDrop(data) {\n  if (!isBrowser)\n    return;\n  if (!Array.isArray(data))\n    data = [data];\n  data.forEach((dnd) => {\n    const { parent, values, ...rest } = dnd;\n    handleVueElements(parent, handleParent(rest, values));\n  });\n}\nfunction useDragAndDrop(initialValues, options = {}) {\n  const parent = ref();\n  const values = ref(initialValues);\n  function updateConfig(config = {}) {\n    dragAndDrop({ parent, values, ...config });\n  }\n  dragAndDrop({ parent, values, ...options });\n  onUnmounted(() => parent.value && tearDown(parent.value));\n  return [parent, values, updateConfig];\n}\nfunction handleParent(config, values) {\n  return (parent) => {\n    parentValues.set(parent, values);\n    initParent({\n      parent,\n      getValues,\n      setValues,\n      config: {\n        ...config,\n        dropZones: []\n      }\n    });\n  };\n}\nexport {\n  dragAndDrop,\n  useDragAndDrop\n};\n//# sourceMappingURL=index.mjs.map"],"names":["throttle","callback","limit","wait","args","splitClass","className","x","isBrowser","addClass","els","omitAppendPrivateClass","classNames","node","isNode","nodes","privateClasses","nodeData","className2","removeClass","getScrollParent","childNode","parentNode","overflow","getElFromPoint","eventData","newX","newY","target","isParent","invalidEl","parents","parentData","targetNodeData","targetParentData","el","addEvents","events2","abortController","eventName","handler","copyNodeStyle","sourceNode","targetNode","omitKeys","computedStyle","omittedKeys","key","child","targetChild","eventCoordinates","data","animations","animationsConfig","slideUp","slideDown","slideLeft","slideRight","parent","state","duration","animate","nodeRect","nodeIndex","ascendingDirection","adjacentNode","xDiff","yDiff","animation","scrollConfig","resetState","setDragState","dragStateProps2","setTouchState","dragState","touchStateProps","dragStateProps","y","performSort","state2","draggedValues","dragValues","newParentValues","parentValues","setParentValues","values","updateConfig","config","dragAndDrop","getValues","setValues","e","handleScroll","tearDown","handleDragstart","handleDragoverNode3","handleDragoverParent2","handleEnd","handleTouchstart","handleTouchmove","handleTouchOverNode3","handleTouchOverParent3","handleDragenterNode","handleDragleaveNode","performTransfer","setupNode","setupNodeRemap","reapplyDragClasses","tearDownNode","tearDownNodeRemap","remapFinished","nodesMutated","_a","plugin","_b","_c","setup","remapNodes","parentEventData","mutationList","parentEl","force","enabledNodes","enabledNodeRecords","prevNodeData","x2","draggedNode","setupNodeData","dragstart","dragstartClasses","draggingClass","dropZoneClass","initDrag","validateDragHandle","dragHandles","coordinates","elFromPoint","handle","touchstart","touchState","initTouch","handleTouchedNode","handleLongTouch","originalZIndex","sort","transfer","nodeEventData","_e","_d","end","_eventData","preventDefault","clonedNode","rect","touchmove","touchmoveClasses","getScrollData","width","height","xThresh","yThresh","scrollOutside","shouldScroll","direction","shouldScrollDown","shouldScrollUp","shouldScrollRight","shouldScrollLeft","diff","moveTouchedNode","touchStartLeft","touchStartTop","touchMoveEventData","performScroll","dragoverNode3","validateTransfer","targetConfig","initialParentConfig","_state","validateSort","targetRect","dragRect","incomingDirection","threshold","range","nodeTargetData","targetData","lastParentValues","targetParentValues","reset","targetIndex","parentTargetData","getEl","handleVueElements","elements","cb","element","validEl","stop","watch","newEl","validEl2","newValues","currentValues","dnd","rest","handleParent","initParent"],"mappings":"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","x_google_ignoreList":[0,1]}