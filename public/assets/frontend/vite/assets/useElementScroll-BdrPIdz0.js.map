{"version":3,"file":"useElementScroll-BdrPIdz0.js","sources":["../../../../../app/frontend/apps/desktop/composables/useElementScroll.ts"],"sourcesContent":["// Copyright (C) 2012-2025 Zammad Foundation, https://zammad-foundation.org/\n\nimport { useScroll, useThrottleFn } from '@vueuse/core'\nimport { whenever } from '@vueuse/shared'\nimport { computed, type ComputedRef, isRef, ref, watch } from 'vue'\n\nimport type { MaybeRef } from '@vueuse/shared'\n\ninterface Options {\n  scrollStartThreshold?: ComputedRef<number | undefined>\n}\n\nexport const useElementScroll = (\n  scrollContainerElement: MaybeRef<HTMLElement>,\n  options?: Options,\n) => {\n  const { y, directions } = useScroll(scrollContainerElement, {\n    eventListenerOptions: { passive: true },\n  })\n\n  const isScrollingDown = ref(false)\n  const isScrollingUp = ref(false)\n\n  const resetScrolls = () => {\n    isScrollingDown.value = false\n    isScrollingUp.value = false\n  }\n\n  const reachedTop = computed(() => y.value === 0)\n\n  const scrollNode = computed(() =>\n    isRef(scrollContainerElement)\n      ? scrollContainerElement.value\n      : scrollContainerElement,\n  )\n\n  const reachedBottom = computed(\n    () =>\n      // NB: Check if this is the most optimal calculation.\n      //   In Webkit based browsers it sometimes results in -0.5 right on the bottom edge,\n      //   hence the need for the lower bound.\n      y.value -\n        (scrollNode.value?.scrollHeight ?? 0) +\n        (scrollNode.value?.offsetHeight ?? 0) >\n      -1,\n  )\n\n  const isScrollable = computed(\n    () =>\n      scrollNode.value?.scrollHeight > scrollNode.value?.clientHeight ||\n      y.value > 0,\n  )\n\n  const hasReachedThreshold = computed(\n    () => y.value > (options?.scrollStartThreshold?.value || 0),\n  )\n\n  const omitValueChanges = computed(() => {\n    return !hasReachedThreshold.value || !isScrollable.value || reachedTop.value\n  })\n\n  whenever(reachedTop, resetScrolls, { flush: 'post' })\n\n  const throttledFn = useThrottleFn((newY, oldY) => {\n    if (omitValueChanges.value) return\n\n    if (hasReachedThreshold.value) {\n      resetScrolls()\n    }\n\n    if (newY > oldY) {\n      isScrollingDown.value = true\n      isScrollingUp.value = false\n    }\n\n    if (newY < oldY) {\n      isScrollingDown.value = false\n      isScrollingUp.value = true\n    }\n  }, 500) // avoid scrolling glitch\n\n  watch(y, throttledFn, { flush: 'post' })\n\n  return {\n    y,\n    directions,\n    reachedTop,\n    reachedBottom,\n    isScrollingDown,\n    isScrollingUp,\n    isScrollable,\n  }\n}\n"],"names":["useElementScroll","scrollContainerElement","options","y","directions","useScroll","isScrollingDown","ref","isScrollingUp","resetScrolls","reachedTop","computed","scrollNode","isRef","reachedBottom","_a","_b","isScrollable","hasReachedThreshold","omitValueChanges","whenever","throttledFn","useThrottleFn","newY","oldY","watch"],"mappings":"8EAYa,MAAAA,EAAmB,CAC9BC,EACAC,IACG,CACH,KAAM,CAAE,EAAAC,EAAG,WAAAC,GAAeC,EAAUJ,EAAwB,CAC1D,qBAAsB,CAAE,QAAS,EAAK,CAAA,CACvC,EAEKK,EAAkBC,EAAI,EAAK,EAC3BC,EAAgBD,EAAI,EAAK,EAEzBE,EAAe,IAAM,CACzBH,EAAgB,MAAQ,GACxBE,EAAc,MAAQ,EAAA,EAGlBE,EAAaC,EAAS,IAAMR,EAAE,QAAU,CAAC,EAEzCS,EAAaD,EAAS,IAC1BE,EAAMZ,CAAsB,EACxBA,EAAuB,MACvBA,CAAA,EAGAa,EAAgBH,EACpB,IAAA,SAIE,OAAAR,EAAE,SACCY,EAAAH,EAAW,QAAX,YAAAG,EAAkB,eAAgB,MAClCC,EAAAJ,EAAW,QAAX,YAAAI,EAAkB,eAAgB,GACrC,GAAA,EAGEC,EAAeN,EACnB,aACE,QAAAI,EAAAH,EAAW,QAAX,YAAAG,EAAkB,gBAAeC,EAAAJ,EAAW,QAAX,YAAAI,EAAkB,eACnDb,EAAE,MAAQ,EAAA,EAGRe,EAAsBP,EAC1B,IAAMR,EAAE,MAAiD,CAAA,EAGrDgB,EAAmBR,EAAS,IACzB,CAACO,EAAoB,OAAS,CAACD,EAAa,OAASP,EAAW,KACxE,EAEDU,EAASV,EAAYD,EAAc,CAAE,MAAO,MAAQ,CAAA,EAEpD,MAAMY,EAAcC,EAAc,CAACC,EAAMC,IAAS,CAC5CL,EAAiB,QAEjBD,EAAoB,OACTT,IAGXc,EAAOC,IACTlB,EAAgB,MAAQ,GACxBE,EAAc,MAAQ,IAGpBe,EAAOC,IACTlB,EAAgB,MAAQ,GACxBE,EAAc,MAAQ,MAEvB,GAAG,EAEN,OAAAiB,EAAMtB,EAAGkB,EAAa,CAAE,MAAO,MAAQ,CAAA,EAEhC,CACL,EAAAlB,EACA,WAAAC,EACA,WAAAM,EACA,cAAAI,EACA,gBAAAR,EACA,cAAAE,EACA,aAAAS,CAAA,CAEJ"}